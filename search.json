[{"path":"https://simonlabcode.github.io/bakR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 Isaac Vock Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://simonlabcode.github.io/bakR/articles/Further-Analyses.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Going beyond the defaults with bakR","text":"Welcome! vignette discusses exciting hodge-podge additional analyses can done bakR. assumption point worked Getting-Started vignette. case, highly suggest starting coming back ’re familiar standard use cases bakR. topics addressed follows: Performing differential synthesis analysis bakR (DESeq2, see) Assessing mechanisms differential expression non-steady state systems TBD (Keep eyes announcements updates vignette come!) packages going install load order everything presented vignette:","code":"library(bakR)  # Packages that are NOT automatically installed when bakR is installed library(DESeq2) #> Loading required package: S4Vectors #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: 'BiocGenerics' #> The following object is masked from 'package:bakR': #>  #>     plotMA #> The following objects are masked from 'package:stats': #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from 'package:base': #>  #>     anyDuplicated, append, as.data.frame, basename, cbind, colnames, #>     dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep, #>     grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget, #>     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, #>     rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply, #>     union, unique, unsplit, which.max, which.min #>  #> Attaching package: 'S4Vectors' #> The following objects are masked from 'package:base': #>  #>     expand.grid, I, unname #> Loading required package: IRanges #> Loading required package: GenomicRanges #> Loading required package: GenomeInfoDb #> Loading required package: SummarizedExperiment #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: 'MatrixGenerics' #> The following objects are masked from 'package:matrixStats': #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: 'Biobase' #> The following object is masked from 'package:MatrixGenerics': #>  #>     rowMedians #> The following objects are masked from 'package:matrixStats': #>  #>     anyMissing, rowMedians library(pheatmap)  # Packages which are installed when bakR is installed library(dplyr)  #>  #> Attaching package: 'dplyr' #> The following object is masked from 'package:Biobase': #>  #>     combine #> The following object is masked from 'package:matrixStats': #>  #>     count #> The following objects are masked from 'package:GenomicRanges': #>  #>     intersect, setdiff, union #> The following object is masked from 'package:GenomeInfoDb': #>  #>     intersect #> The following objects are masked from 'package:IRanges': #>  #>     collapse, desc, intersect, setdiff, slice, union #> The following objects are masked from 'package:S4Vectors': #>  #>     first, intersect, rename, setdiff, setequal, union #> The following objects are masked from 'package:BiocGenerics': #>  #>     combine, intersect, setdiff, union #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(magrittr)  #>  #> Attaching package: 'magrittr' #> The following object is masked from 'package:GenomicRanges': #>  #>     subtract library(ggplot2)  library(stats)  # Set the seed for reproducibility set.seed(123)"},{"path":"https://simonlabcode.github.io/bakR/articles/Further-Analyses.html","id":"differential-synthesis-analysis-with-bakr-deseq2","dir":"Articles","previous_headings":"","what":"Differential synthesis analysis with bakR + DESeq2","title":"Going beyond the defaults with bakR","text":"claim bakR tool performing differential kinetic analysis, coming Getting-Started vignette might think misnomer. showed vignette differential stability analysis. Full-fledged differential kinetic analysis means performing differential synthesis analysis well, let’s talk can bakR. title section suggests though, bakR won’t able accomplish task alone. reason assessing changes synthesis means assessing changes RNA stability RNA expression. Therefore, need perform differential expression analysis conjunction differential stability analysis. theory, implemented differential expression analysis bakR, many popular software tools currently existence perform task, seemed pointlessly redundant. also gives freedom use whatever differential expression analysis tool used using, perform whatever kind DE analysis like independent bakR. show perform differential synthesis analysis, using DESeq2 purpose differential expression analysis. ? like DESeq2. ’s good model, ’s good piece software, early source inspiration PhD. Also, ’ll see output bakR specifically designed DESeq2 mind, facilitate process performing differential expression analysis bit. First things first, let’s simulate data! ’ll simulate 1000 genes, 200 observing differential synthesis changes stability. Let’s also run efficient implementation . second step perform differential expression analysis. alluded , bakR makes bit easier, way providing count matrix formatted just DESeq2 likes ! DESeq2 also requires one input, dataframe provides information covariates (things distinguish samples). code produce necessary inputs make sure correctly mapped samples experimental conditions colData object, can create sweet sweet DESeqDataObject invite read DESeq2 documentation need help understanding call DESeqDataSetFromMatrix. short though, first entry count matrix, second colData object, final entry design matrix. Limma’s documentation (another differential expression analysis software) great introduction design matrices, one simple. means want group samples together value conditions factor colData object. “ref” samples grouped together “exp” samples grouped together. DESeq2 compare different groups, means compare “exp” “ref” samples case. Now can fit DESeq2 extract differential expression analysis results: sake, going use two columns reso object: log2FoldChange lfcSE. column names pretty self-explanatory, completeness sake, log2FoldChange log base-2 fold change RNA expression, lfcSE standard error log2FoldChange. , need perform differential synthesis analysis! may ask? Well, population cells performed RNA-seq steady-state (.e., cells actively responding perturbation treating metabolic label), following relationship holds \\(ksyn\\) (RNA synthesis rate) \\(kdeg\\) (RNA degradation rate) \\([RNA]\\) (RNA concentration): \\[ [RNA] = \\frac{ksyn}{kdeg} \\] Therefore, log2 fold change \\([RNA]\\) (\\(L2FC(RNA)\\)) : \\[ \\begin{align} L2FC(RNA) &= log_2(\\frac{[RNA_{exp}]}{[RNA_{ref}]}) \\\\           &= log_2(\\frac{ksyn_{exp}*kdeg_{ref}}{ksyn_{ref}*kdeg_{exp}}) \\\\           &= log_2(\\frac{ksyn_{exp}}{ksyn_{ref}}) - log_2(\\frac{kdeg_{exp}}{kdeg_{ref}}) \\\\           &= L2FC(ksyn) - L2FC(kdeg) \\end{align} \\] Therefore, key conclusion performing differential synthesis analysis : \\[ L2FC(ksyn) = L2FC(RNA) + L2FC(kdeg) \\] bakR provides \\(L2FC(kdeg)\\) DESeq2 provides \\(L2FC(RNA)\\), everything need calculate \\(L2FC(ksyn)\\). Let’s make data.frame information: missing one key component though: uncertainty (standard error). can get bakR DESeq2? Well easiest conservative thing assume independence \\(L2FC(RNA)\\) \\(L2FC(kdeg)\\). ’s variances independent random variables add, : \\[ \\begin{align} \\text{Var}[L2FC(ksyn)] &= \\text{Var}[L2FC(kdeg) + L2FC(RNA)] \\\\ &= \\text{Var}[L2FC(kdeg)] + \\text{Var}[L2FC(RNA)] \\end{align} \\] \\(\\text{Var}[X]\\) variance random variable \\(X\\). can calculate standard error square root variance, meaning: \\[  \\text{se}[L2FC(ksyn)] = \\sqrt{se[L2FC(kdeg)]^2 + se[L2FC(RNA)]^2} \\] using non-standard notation \\(\\text{se}[X]\\) mean standard error \\(X\\). , can fill final component L2FC(ksyn) dataframe: se Effects_df log base-e fold change \\(kdeg\\), use fact : \\[ \\text{Var}[*X] = ^2*\\text{Var}[X] \\] constant . case, \\(log_2(e)\\) multiplicative factor necessary convert log base-2 log base-e. Now left calculate p-value multiple-test adjust (going use Benjamini-Hochberg multiple test adjustment bakR DESeq2 use). can now make \\(L2FC(ksyn)\\) volcano plot visualize final conclusions!  simulation features number 1-800 non-differentially synthesized RNA features 801-1000 200 differentially synthesized RNA. Therefore, can also see analysis performed  FP false positive, FN false negative, TP true positive, TN true negative. , ’d say went pretty well! now know perform differential synthesis analysis bakR + DEseq2.","code":"# Simulate a nucleotide recoding dataset sim_data <- Simulate_bakRData(1000,                          num_kd_DE = c(0, 0),                          num_ks_DE = c(0, 200))   # This will simulate 500 features, 2 experimental conditions   # and 3 replicates for each experimental condition   # See ?Simulate_bakRData for details regarding tunable parameters  # Extract simulated bakRData object bakRData <- sim_data$bakRData  # Extract simualted ground truths sim_truth <- sim_data$sim_list  ## Run the efficient model # We'll tell it what the mutation rates are just for efficiency's sake Fit <- bakRFit(bakRData, pnew = rep(0.05, times = 6), pold = 0.001) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance # Get the count matrix from bakR Counts <- Fit$Data_lists$Count_Matrix  # Experimental conditions for each sample # There are 6 s4U treated samples (3 replicates of each condition) # In addition, there are 2 -s4U control samples (1 for each condition)  ## s4U conditions # 1st three samples are reference (ref) samples # Next three samples are experimental (exp) samples conditions_s4U <- as.factor(rep(c(\"ref\", \"exp\"), each = 3))  ## -s4U control conditions # 1st sample is reference, next is experimental conditions_ctl <- as.factor(c(\"ref\", \"exp\"))  # Combined s4U and -s4U control conditions conditions <- c(conditions_s4U, conditions_ctl)  # Make the colData input for DESeq2 colData <- data.frame(conditions = conditions) rownames(colData) <- colnames(Counts)  # Take a look at the colData object print(t(colData)) dds <- DESeqDataSetFromMatrix(countData = Counts,                               colData = colData,                               design = ~conditions) #> converting counts to integer mode ddso <- DESeq(dds) #> estimating size factors #> estimating dispersions #> gene-wise dispersion estimates #> mean-dispersion relationship #> final dispersion estimates #> fitting model and testing  # Extract results of experimental vs. reference comparison reso <- results(ddso, contrast = c(\"conditions\", \"exp\", \"ref\"))  # Look at the column names of the reso object colnames(as.data.frame(reso)) #> [1] \"baseMean\"       \"log2FoldChange\" \"lfcSE\"          \"stat\"           #> [5] \"pvalue\"         \"padj\" ksyn_df <- data.frame(L2FC = reso$log2FoldChange + Fit$Fast_Fit$Effects_df$L2FC_kdeg,                       Gene = Fit$Fast_Fit$Effects_df$XF) ksyn_df$se <- sqrt(reso$lfcSE^2 + (Fit$Fast_Fit$Effects_df$se*log2(exp(1)))^2 ) # Calculate p-value using asymptotic Wald test ksyn_df <- ksyn_df %>%   mutate(pval = 2*pnorm(-abs(L2FC/se)),          padj = p.adjust(pval, method = \"BH\")) # Add conclusion at 0.01 FDR control ksyn_df <- ksyn_df %>%   mutate(conclusion = as.factor(ifelse(padj < 0.01,                               ifelse(L2FC < 0, \"Decreased txn\", \"Increased txn\"),                              \"Not sig.\")))  # Make volcano plot ksyn_volc <- ggplot(ksyn_df, aes(x = L2FC, y = -log10(padj), color = conclusion)) +    theme_classic() +    geom_point(size = 1) +    xlab(\"L2FC(ksyn)\") +    ylab(\"-log10(padj)\") +    scale_color_manual(values = c(\"blue\", \"orange\", \"gray\"))  # Observe volcano plot ksyn_volc # Add conclusion at 0.01 FDR control ksyn_df <- ksyn_df %>%   mutate(result = as.factor(ifelse(padj < 0.01,                               ifelse(as.integer(Gene) <= 800, \"FP\", \"TP\"),                              ifelse(as.integer(Gene) <= 800, \"TN\", \"FN\"))))  # Make volcano plot ksyn_results <- ggplot(ksyn_df, aes(x = L2FC, y = -log10(padj), color = result)) +    theme_classic() +    geom_point(size = 1) +    xlab(\"L2FC(ksyn)\") +    ylab(\"-log10(padj)\") +    scale_color_manual(values = c(\"black\", \"gray\", \"forestgreen\", \"blue\"))  # Observe volcano plot ksyn_results"},{"path":"https://simonlabcode.github.io/bakR/articles/Further-Analyses.html","id":"going-beyond-the-steady-state-assumption","dir":"Articles","previous_headings":"","what":"Going beyond the steady-state assumption","title":"Going beyond the defaults with bakR","text":"may noticed assumption continually crops analyses presented bakR vignettes: steady-state. Getting-Started vignette, necessary part relating fraction new interesting \\(kdeg\\). vignette, additionally key part assessing synthesis kinetics. therefore underlies differential kinetic analysis discussed far. happens bad assumption? “Dogs cats living together! Mass hysteria!”? Dr. Venkman, ’s way , ’s ’re going talk next.","code":""},{"path":"https://simonlabcode.github.io/bakR/articles/Further-Analyses.html","id":"violating-the-steady-state-assumption","dir":"Articles","previous_headings":"Going beyond the steady-state assumption","what":"Violating the steady-state assumption","title":"Going beyond the defaults with bakR","text":"talk steady-state assumption questionable, ’s worth briefly mentioning steady-state assumption worth throwing . Assuming steady-state RNA dynamics means assuming rate RNA synthesized rate degraded. “Wait, mean assuming \\(ksyn = kdeg\\)?” . degradation rate constant \\(kdeg\\) rate degradation. rate degradation (.e., number RNA molecules degraded per unit time) depends \\(kdeg\\) amount RNA present. steady-state actually means \\(ksyn = kdeg*[RNA]\\). context NR-seq experiments, assuming steady-state means assuming relationship holds throughout entire metabolic label feed time. Therefore, another way phrase assumption say assuming population cells aren’t actively responding stimulus regulating \\(ksyn\\) /\\(kdeg\\). RNA levels remain constant experiment. ’s fun question: cells ever steady-state? Yes . individual cell NEVER steady-state. Gene expression constantly regulated cell progresses cell cycle performs biochemical functions necessary stay alive. , bakR designed analyze bulk nucleotide recoding RNA-seq data. means data comes population cells, single cell. Thus, say assuming steady-state, really mean assuming population average steady-state. population cells asynchronous (aren’t going exact cell cycle stages time) haven’t perturbed recently (e.g., treated drug), probably pretty solid assumption. Lots cool experiments done cells far steady-state though. using nucleotide recoding RNA-seq, increasingly popular perform rapid degradation protein interest, treatment specific drug, acute perturbation leading metabolic labeling. Therefore, need way analyze data without helpful steady-state assumption. challenging though, can’t assume steady-state, relate measure (fraction new) RNA metabolic kinetics care ? answer: keep non-parametric.","code":""},{"path":"https://simonlabcode.github.io/bakR/articles/Further-Analyses.html","id":"analyzing-nr-seq-data-far-from-steady-state","dir":"Articles","previous_headings":"Going beyond the steady-state assumption","what":"Analyzing NR-seq data far from steady-state","title":"Going beyond the defaults with bakR","text":"using term non-parametric suggest getting away using explicit mathematical functions model RNA metabolism. Rather, can think generally effects changes RNA synthesis degradation kinetics can fraction new NR-seq experiment. Let’s say compare unperturbed, steady-state population cells cells treated drug interest. fraction new particular transcript higher drug treated cells untreated cells, come ? Well, generally speaking, two possibilities: RNA may destabilized drug treatment. explanation give change everything steady-state. synthesis rate RNA may ramped following drug treatment. intuitive explanation surprisingly possible away steady-state. steady-state, changes synthesis kinetics affect amount new old RNA equally, leading change fraction new. key realization: two possibilities different impacts LEVELS RNA. synthesis increasing upon drug treatment, amount transcript also increase. transcript destabilized though, less around end experiment. Therefore, combining differential expression differential fraction new analyses reveals kinetic differences. generally, diagram covers range possible kinetic mechanisms conclusions: Diagram NR-seq NSS analysis strategy.","code":""},{"path":"https://simonlabcode.github.io/bakR/articles/Further-Analyses.html","id":"performing-steady-state-independent-comparisons-with-bakr-deseq2","dir":"Articles","previous_headings":"Going beyond the steady-state assumption","what":"Performing steady-state independent comparisons with bakR + DESeq2","title":"Going beyond the defaults with bakR","text":"goal steady-state independent analysis putting forth identify major kinetic mechanism differential expression observed. analysis strategy follows: Compare NR-seq bakR (one small parameter tweak) Perform differential expression analysis Use NSSHeat() function bakR combine results come mechanistic conclusion. Simple enough! usual, let’s start simulating data. Unfortunately, since non-steady state (NSS) broad term, NSS simulation option. ’s okay though, analysis strategy still work even steady-state assumption isn’t invalid. make interesting though, ’ll simulate mix synthesis degradation changes: ’s interesting simulation transcripts differentially stable also differentially synthesized, goal identify major source kinetic regulation. Also, note change bakRFit() call; parameter called NSS set TRUE. make bakR compares logit(fraction new)s rather log(kdeg)s, since relationship fraction new \\(kdeg\\) may longer hold. Next, can perform differential expression analysis just : ’re almost ready use bakR’s special NSSHeat() function. NSSHeat() two required inputs: bakR fit object (preferably fit NSS set TRUE) data frame containing differential expression analysis results particular, differential expression data frame must contain four columns named follows: XF: Name feature (gene, exon, etc.) read comes . log2FoldChange: L2FC(RNA) estimated differential expression analysis. stat: L2FC(RNA)/se[L2FC(RNA)]; like differential expression z-score. padj: Multiple test adjusted p-value differential expression analysis. Conveniently, DESeq2 results object information need! can make differential expression data frame like : ready perform steady-state independent analysis now! See ?NSSHeat information additional parameters can specified. importantly, bakRModel parameter, tells NSSHeat fit use bakRFit model, multiple exist. default setting just use MLE fit, always . can output NSSHeat? Well, name implies, function specifically designed help make heatmaps. NSSheatmap three columns: bakR_score: logit(fraction new) change z-score bakR DE_score: L2FC(RNA) z-score DESeq2 Mech_score: mechanism z-score quantifies extent significant changes gene expression synthesis degradation driven. Synthesis driven = positive numbers; degradation driven = negative numbers. can quickly make heatmap using lovely pheatmap package:  row data frame output NSSHeat corresponds feature differentially expressed experimental condition. Features identified differentially expressed can either result underpowered analysis (.e., really differentially expressed two conditions replicates/sequencing depth required identify confidently) complicated concomitant modulation synthesis degradation kinetics. makes non-differentially expressed features difficult analyze strategy, bakR focuses differentially expressed features.","code":"# Simulate a nucleotide recoding dataset sim_data <- Simulate_bakRData(1000,                          num_kd_DE = c(0, 200),                          num_ks_DE = c(0, 200))   # This will simulate 1000 features, 2 experimental conditions   # and 3 replicates for each experimental condition.   # See ?Simulate_bakRData for details regarding tunable parameters  # Extract simulated bakRData object bakRData <- sim_data$bakRData  # Extract simualted ground truths sim_truth <- sim_data$sim_list  ## Run the efficient model Fit <- bakRFit(bakRData, NSS = TRUE) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 6 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0500 #> 2     1     2 0.0501 #> 3     1     3 0.0500 #> 4     2     1 0.0500 #> 5     2     2 0.0501 #> 6     2     3 0.0498 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.00100146098140918 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance # Get the count matrix from bakR Counts <- Fit$Data_lists$Count_Matrix  # Experimental conditions for each sample # There are 6 s4U treated samples (3 replicates of each condition) # In addition, there are 2 -s4U control samples (1 for each condition)  ## s4U conditions # 1st three samples are reference (ref) samples # Next three samples are experimental (exp) samples conditions_s4U <- as.factor(rep(c(\"ref\", \"exp\"), each = 3))  ## -s4U control conditions # 1st sample is reference, next is experimental conditions_ctl <- as.factor(c(\"ref\", \"exp\"))  # Combined s4U and -s4U control conditions conditions <- c(conditions_s4U, conditions_ctl)  # Make the colData input for DESeq2 colData <- data.frame(conditions = conditions) rownames(colData) <- colnames(Counts)  # Make DESeq2 data object dds <- DESeqDataSetFromMatrix(countData = Counts,                               colData = colData,                               design = ~conditions) #> converting counts to integer mode  # Fit DESeq2 model ddso <- DESeq(dds) #> estimating size factors #> estimating dispersions #> gene-wise dispersion estimates #> mean-dispersion relationship #> final dispersion estimates #> fitting model and testing  # Extract results of experimental vs. reference comparison reso <- results(ddso, contrast = c(\"conditions\", \"exp\", \"ref\")) # Convert to data frame reso <- as.data.frame(reso)  # Make data frame DE_df <- data.frame(XF = row.names(reso),                     log2FoldChange = reso$log2FoldChange,                     stat = reso$stat,                     padj = reso$padj) NSSheatmap <- NSSHeat(Fit, DE_df) # NSS heatmap pheatmap(NSSheatmap, cluster_cols = FALSE, show_rownames = FALSE)"},{"path":"https://simonlabcode.github.io/bakR/articles/Getting-Started.html","id":"necessary-setup","dir":"Articles","previous_headings":"","what":"Necessary Setup","title":"Differential kinetic analysis with bakR","text":"course want load bakR package vignette; instructions can found link. Also, ’ll want set seed ensure results get reproduce presented vignette.","code":"library(bakR) set.seed(123)"},{"path":"https://simonlabcode.github.io/bakR/articles/Getting-Started.html","id":"step-1-creating-a-bakrdata-object","dir":"Articles","previous_headings":"","what":"Step 1: Creating a bakRData Object","title":"Differential kinetic analysis with bakR","text":"1st step using bakR create bakRData object. bakRData object consists two components: cB dataframe metadf dataframe. cB stands counts binomial contains information mutations seen sequencing reads sample sequenced. metadf stands metadata data frame contains important information experimental details sample (.e., long metabolic label feed , samples reference samples, experimental samples). Lets get idea cB looks like taking peak example: One key aspect cB dataframe keep mind row corresponds set reads providing identical data. help make sense, understand information cB tracks, let’s go contents column: sample: name sample reads described row originated. Usually sort character vector defined. TC: Number U--C mutations (assuming using 4sU metabolic label). Called TC technically data T--C mutations reverse-transcribed RNA nT: Number Ts (Us RNA) sequencing read(s) XF stands “exonic feature”, since cases considering reads map definitively exonic locations. Introns typically rapidly turned thus highly labeled species bias estimates mature transcript stability. n: Number reads identical data 4 columns. example, n = 3 2nd row means 3 reads sample WT_cntl (WT cells treated s4U) mapped XF ENSG00000100242 (SUN2), 0 T C mutations, 11 Ts. structure cB file closely reflects output pipeline analyzing nucleotide recoding RNA-seq data developed Simon lab (available ), consists data provided another published pipeline, SLAMDUNK (see alleyoop dump function SLAMDUNK). Now let’s look corresponding metadf dataframe: transpose metadf displayed save space (columns depicted rows metadf, vice versa). Metadf significantly less information cB data frame, ’s crucial information. One extremely important feature metadf row names (column names depicted ). Examine row names compare sample names ’re , !! row metadf corresponds sample, order sample names appear row names metadf MUST correspond order appear cB sample column. Keeping mind row represents sample, content columns : tl: length metabolic labeling feed. can units (simulated data puts terms minutes), 4sU fed sample, tl must 0 sample. -4sU controls play important role statistical models, crucial remember. technically necessary run bakR, always highly suggest including controls. want compare two experimental samples, can done output models, though require bit post-hoc work end. later… two data frames correctly constructed, can create bakRData object one line code.","code":"# Load small example cB data(\"cB_small\")  # Observe contents of cB head(cB_small) # Load metadf data frame; will be loaded as metadf in global environment data(\"metadf\")  # Print the transpose of metadf # Rows will be the columns and columns will be the rows print(t(metadf)) # metadf row names print(rownames(metadf)) #> [1] \"WT_ctl\" \"WT_2\"   \"WT_1\"   \"KO_ctl\" \"KO_2\"   \"KO_1\"   # cB sample names print(unique(cB_small$sample)) #> [1] \"WT_ctl\" \"WT_2\"   \"WT_1\"   \"KO_ctl\" \"KO_2\"   \"KO_1\" # Create bakRData object bakRData <- bakRData(cB_small, metadf)"},{"path":"https://simonlabcode.github.io/bakR/articles/Getting-Started.html","id":"step-2-fitting-the-efficient-model","dir":"Articles","previous_headings":"","what":"Step 2: Fitting the Efficient Model","title":"Differential kinetic analysis with bakR","text":"bakR implements several blends fundamentally similar statistical models perform differential kinetic analysis. matter intentions though, must first fit data efficient model available. model (implemented fast_analysis() function, see ?fast_analysis details) estimates mutation rates finds maximum likelihood estimate (MLE) fraction sequencing reads new RNA (new meaning RNA synthesized start metabolic labeling) feature 4sU fed sample. reason run model part output used every model can run bakR. later though; first, let’s create simulated dataset fit efficient model. Using simulated dataset allow us compare results ground truth validate accuracy. bakRFit() used wrapper two functions bakR: cBprocess() fast_analysis(). cBprocess() extract properly format information needed statistical models bakRData object fast_analysis() perform efficient analysis. take minute run. Messages printed along way keep updated progress analysis. One important messages regarding estimated pnews pold. pnews estimated mutation rates reads new RNAs (new meaning RNAs synthesized start 4sU labeling) sample (muts = Exp_ID, reps = numerical replicate ID corresponds order replicates appear cB), pold global estimate background mutation rate used analyses. simulated mutation rates 0.05 new reads 0.001 old reads samples simulation, estimates pretty darn close. can also input mutation rate estimates elsewhere (say run full Stan model implemented bakR) bakRFit(): Since ’ve already run fast_analysis , can speed analysis passing Fit object first run rather bakRData object. allows bakR skip time consuming pre-processing steps. Just make sure set FastRerun TRUE. run problems default mutation rate strategy (e.g., mutation rate estimates don’t seem make sense) another slightly less efficient solution use MCMC implemented Stan estimate mutation rates. idea fit binomial mixture model small subset features sufficient sequencing depth model enough data work . strategy used go-strategy, made improvements default mutation rate strategy found using approach less less. Still, example use posterity’s sake: matter decide run fast model, might wonder well worked. mentioned earlier, one benefit using simulated data can easily answer question comparing simulated parameters (e.g., fraction new) model’s estimates:  Looks pretty good ! run heavier, trustworthy models, just rerun bakRFit() Fit object, either StanFit HybridFit parameters set true. might rightfully ask makes models “trustworthy”? Didn’t just show logit(fn) estimates fast model pretty good? bother computationally expensive models?? answer lot magic happens level uncertainty quantification. models going agree pretty well estimates kinetic parameters, won’t necessarily agree uncertain estimates . fastest model takes lot shortcuts uses lot approximations make fast also make uncertainty quantification less rigorous. like say fast model used initial investigations data, rapid means satisfy desire dive whatever exciting biology might exploring. sense promising data want analyze, switch heavier models. give peace mind allow comfortably dig little deeper datasets prepare stunning presentations groundbreaking papers. full Stan model (StanFit = TRUE) go-, working unusually large dataset, look hybrid model. general rule thumb constitutes large dataset case (number experimental conditions) x (number replicates condition) greater 15. example, 3 replicates 6 different conditions (3 x 6 = 18) going take full model process, likely order weeks. Fit objects contain lists pertaining fits models. possible contents include: Fast_Fit: Result initial fitting bakRData object. learn contents, see ?fast_analysis() Data_lists: Processed data can passed statistical models Hybrid_Fit: Result running bakRFit() Fit object HybridFit = TRUE. learn contents, see ?TL_stan(). Stan_Fit: Result running bakRFit() Fit object StanFit = TRUE. general contents identical Hybrid_Fit, even though models different.","code":"# Simulate a nucleotide recoding dataset sim_data <- Simulate_bakRData(500)   # This will simulate 500 features, 2 experimental conditions   # and 3 replicates for each experimental condition   # See ?Simulate_bakRData for details regarding tunable parameters  # Extract simulated bakRData object bakRData <- sim_data$bakRData  # Extract simualted ground truths sim_truth <- sim_data$sim_list  # Run the efficient model Fit <- bakRFit(bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 6 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0501 #> 2     1     2 0.0499 #> 3     1     3 0.0500 #> 4     2     1 0.0501 #> 5     2     2 0.0502 #> 6     2     3 0.0500 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.000999785857498937 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance # Run efficient model with known mutation rates # Pass the Fit object rather than the bakRData object and set FastRerun to TRUE Fit <- bakRFit(Fit,                      FastRerun = TRUE,                      pnew = rep(0.05, times = 6),                       pold = 0.001) #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance # Set StanRateEst to TRUE to use Stan to estimate rates # low_reads and high_reads defines the read count cutoffs used to select features   # default = between 1000 and 5000 reads # RateEst_size determines the number of features to use (default = 7) Fit <- bakRFit(Fit,                      FastRerun = TRUE,                      StanRateEst = TRUE,                      low_reads = 500,                      high_reads = 5500,                      RateEst_size = 5) # Features that made it past filtering XFs <- unique(Fit$Fast_Fit$Effects_df$XF)  # Simulated logit(fraction news) from features making it past filtering true_fn <- sim_truth$Fn_rep_sim$Logit_fn[sim_truth$Fn_rep_sim$Feature_ID %in% XFs]  # Estimated logit(fraction news) est_fn <- Fit$Fast_Fit$Fn_Estimates$logit_fn  # Compare estimate to truth plot(true_fn, est_fn, xlab = \"True logit(fn)\", ylab = \"Estimated logit(fn)\") abline(0, 1, col = \"red\") # Load options that will make running models more efficient rstan::rstan_options(auto_write = TRUE) options(mc.cores = parallel::detectCores())   # Run Hybrid model (This might take several minutes to run) Fit <- bakRFit(Fit, HybridFit = TRUE)  # Run Full model (This might take ~10-30 minutes to run) Fit <- bakRFit(Fit, StanFit = TRUE)"},{"path":"https://simonlabcode.github.io/bakR/articles/Getting-Started.html","id":"step-3-visualizing-the-results","dir":"Articles","previous_headings":"","what":"Step 3: Visualizing the Results","title":"Differential kinetic analysis with bakR","text":"bakR provides variety easy use functions beginning investigate data. visualizations particularly aimed revealing trends RNA stabilization destabilization. Analyzing changes RNA synthesis rate require pairing output bakR differential expression analysis tool, like DESeq2 limma. later. One visualization powered bakR L2FC(kdeg) MA plot. point plots represent feature-condition combination. x-axis average number sequencing reads mapping feature, averaging replicates experimental reference condition. y-axis difference stability reference experimental condition, quantified log2-fold change (L2FC) degradation rate constant (kdeg). Positive values L2FC(kdeg) represent features less stable (higher kdeg) experimental condition relative reference condition. Negative values thus represent features stable experimental condition. plotMA function bakR allows make plot two inputs, bakRFit object model fit use (MLE, Hybrid, MCMC):  one experimental condition, can choose plot comparisons just subset interested. See Exps Exp_shape parameters ?plotMA help file details. Another common plot make bakR fits volcano plot. x-axis volcano plot y-axis MA plot (L2FC kinetic parameter), y-axis measure statistical significance (e.g., FDR adjusted p-value), usually -log10 scale. plotVolcano function help one , containing many parameters plotMA:  volcano MA plots great visualizing results bakR’s model fits, another important class plots detect anomalies. Sometimes, high-throughput sequencing datasets plagued batch effects, biases effect one samples. can lead inflated false discovery rates /reduced power thus important look . One simple way see large-scale biases present samples perform principle component analysis (PCA), dimension reduction algorithm project high-dimensional sequencing data onto dimensions. bakR specifically implements novel fraction new PCA, high-dimensional object compressed matrix fraction new estimates, column matrix corresponding sample row feature (e.g., transcript). replicates don’t cluster together 2D PCA plot produced bakR’s FnPCA, indicate presence batch effects:  case, replicates separate fairly well, promising difference red point lower left upper left significant enough cause concern. found clustering improved full MCMC fit, ’ve taken time run model, suggest using PCA plots.","code":"## MA Plot with Fast Fit bakR::plotMA(Fit, Model = \"MLE\") ## Volcano Plot with Fast Fit; significance assessed relative to an FDR control of 0.05 plotVolcano(Fit$Fast_Fit) ## 2D PCA plot with replicate fraction news FnPCA(Fit$Fast_Fit)"},{"path":"https://simonlabcode.github.io/bakR/articles/Getting-Started.html","id":"step-4-where-to-go-from-here","dir":"Articles","previous_headings":"","what":"Step 4: Where to go from here","title":"Differential kinetic analysis with bakR","text":"hope vignette provided useful introduction using bakR nucleotide recoding RNA-seq datasets. Inevitably, questions answered Getting-Started vignette. remaining quandaries may challenging problems specific exciting research, unavoidable roadblocks science eventually conquer, little help documentation dream writing. said, can still imagine many important implementation questions addressed , like: estimating comparing synthesis rates? bakR seems automatically perform degradation rate constant comparisons, keep calling differential kinetic analysis, differential stability analysis. gives? ’m sure steady-state assumption ’ve relying holds system. can ? ’m new Stan getting weird warning messages upon running heavier models. rhats effective sample sizes? first two questions interest , head “Going beyond defaults” vignette! second question interest, suggest heading amazing documentation written Stan team. short though, warnings Stan sign model converge. cause likely anomalies data. challenges come across lead warnings include: analyze mix technical biological replicates? Technical replicates much less replicate replicate variability biological replicates, confuse crash models. 4sU label time abnormally long short? getting warnings running MLE implementation logit(fn)s lower upper bounds, case. means extreme mutational data (e.g., 0 mutations sequencing read) make analysis MCMC implementation difficult. Try filtering extreme transcripts rerunning bakR case. extreme batch effects. Check FnPCA plot; extreme differences replicates also break models. analyzing short sequencing reads? bakR yet fully validated short sequencing read nucleotide recoding RNA-seq data (e.g., read lengths less 50 nucleotides), exercise caution analyzing kind data bakR. Mutation rate estimation can also pose challenge bakR case. get around problems, try using mutation rate estimates MCMC implementation (found accurate even model convergence issue) MLE implementation. Sometimes, small warnings Stan (like max treedepth warnings ) cause concern. know whether serious problem though? suggest comparing output Hybrid/MCMC implementation MLE implementation. particular, check correlation L2FC(kdeg) estimates. correlation good, probably nothing worry . estimates handful transcripts differ wildly implementations though, strong evidence model didn’t converge one anomalies mentioned afflicting data.","code":""},{"path":"https://simonlabcode.github.io/bakR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Isaac Vock. Author, maintainer.","code":""},{"path":"https://simonlabcode.github.io/bakR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vock (2022). bakR: Analyze Compare Nucleotide Recoding RNA Sequencing Datasets. R package version 0.2.4, https://simonlabcode.github.io/bakR/.","code":"@Manual{,   title = {bakR: Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets},   author = {Isaac Vock},   year = {2022},   note = {R package version 0.2.4},   url = {https://simonlabcode.github.io/bakR/}, }"},{"path":"https://simonlabcode.github.io/bakR/index.html","id":"brief-description-of-bakr","dir":"","previous_headings":"","what":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","title":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","text":"bakR (Bayesian analysis kinetics RNA) R package performing differential kinetics analysis nucleotide recoding high-throughput RNA sequencing (NR-seq) data. Kinetic parameter estimation statistical testing compatible mutational data enrichment free NR-seq method (e.g., TimeLapse-seq, SLAM-seq, TUC-seq, etc.).","code":""},{"path":"https://simonlabcode.github.io/bakR/index.html","id":"why-use-bakr","dir":"","previous_headings":"","what":"Why use bakR?","title":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","text":"Differential expression analysis RNA sequencing (RNA-seq) data can identify changes cellular RNA levels, determine kinetic mechanism underlying changes. Previously, lab others addressed shortcoming developing nucleotide-recoding RNA-seq methods (NR-seq; e.g., TimeLapse-seq) quantify changes RNA synthesis degradation kinetics. advanced statistical models implemented user-friendly software (e.g., DESeq2) ensured statistical rigor differential expression analyses, tools facilitate differential kinetic analysis NR-seq exist. address need, developed bakR, R package analyzes compares NR-seq datasets. Differential kinetics analysis bakR relies Bayesian hierarchical model NR-seq data increase statistical power sharing information across transcripts. bakR outperforms attempts use single sample analysis tools (e.g., pulseR GRAND-SLAM) differential kinetics analysis. Check preprint learn model extensive validation!","code":""},{"path":"https://simonlabcode.github.io/bakR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","text":"bakR now available CRAN! using Mac OS (version R) Windows R version 4.2.1, means don’t need configure C++ compiler install use bakR. Eventually, also hold users Windows OS version R, CRAN just needs time build binaries older R versions R-devel. Mac OS Windows + R4.2.1 need first properly configure C++ compiler; see next paragraph details links describing . either case, (compiler necessary) ready, bakR can installed follows: install newest version bakR Github, need C++ compiler configured rstan’s (R interface probabilistic programming language Stan bakR uses backend) liking. best way follow Stan team’s helpful documentation installing rstan operating system. complete, can install bakR follows:","code":"install.packages(\"bakR\") install.packages(\"devtools\") # if you haven't installed devtools already devtools::install_github(\"simonlabcode/bakR\")"},{"path":"https://simonlabcode.github.io/bakR/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","text":"currently two vignettes help get speed using bakR: introductory vignette (title: Differential Kinetic Analysis bakR) walks basic bakR workflow simulated data. second vignette (title: Going beyond defaults bakR) dives specific follow-analyses one can perform running bakR dataset. Currently, vignette discusses differential synthesis analysis (.e., identifying differences RNA synthesis rates combining bakR differential expression analysis) performing analyses without assuming steady-state. analyses added vignette time goes . vignettes available bakR website Articles section. link bakR github well need help getting back github website.","code":""},{"path":"https://simonlabcode.github.io/bakR/index.html","id":"obtaining-the-necessary-input","dir":"","previous_headings":"","what":"Obtaining the Necessary Input","title":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","text":"discussed introductory vignette, bakR requires data form -called “cB”, counts binomial data frame. row cB data frame corresponds group reads identical mutational data, columns denote sample reads came, feature reads aligned , number mutations interest reads (e.g., T--C mutations), number mutable positions (e.g. Ts), number reads. reasonable wonder “supposed get information?” couple possibilities, perhaps easiest widely applicable bam2bakR, Snakemake implementation TimeLapse pipeline developed Simon lab. bam2bakR takes input aligned bam files produces, among things, cB file required bakR. Extensive documentation describing get bam2bakR running available GitHub repo. Snakemake greatly facilitates running pipeline almost computational infrastructure bam2bakR uses conda/mamba package manager make setting necessary dependencies breeze. Also look fastq2bakR coming days, similar tool additionally takes care necessary fastq preprocessing alignment!","code":""},{"path":"https://simonlabcode.github.io/bakR/index.html","id":"bug-catching-and-further-questions","dir":"","previous_headings":"","what":"Bug Catching and Further Questions","title":"Analyze and Compare Nucleotide Recoding RNA Sequencing Datasets","text":"Post descriptions bugs simple reproducible example (possible) Issues section repo. fact, go Issues section question bakR, even helpful labels can append posts make nature request clear. email (Isaac Vock) question/concern/suggestion, direct Issues section. basic use questions, suggest going vignettes linked . answer question, post question Issues.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/FnPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating PCA plots with logit(fn) estimates — FnPCA","title":"Creating PCA plots with logit(fn) estimates — FnPCA","text":"function creates 2-component PCA plot using logit(fn) estimates.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/FnPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating PCA plots with logit(fn) estimates — FnPCA","text":"","code":"FnPCA(obj, log_kdeg = FALSE)"},{"path":"https://simonlabcode.github.io/bakR/reference/FnPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating PCA plots with logit(fn) estimates — FnPCA","text":"obj Object contained within output bakRFit. , either Fast_Fit (MLE implementation fit), Stan_Fit (MCMC implementation fit), Hybrid_Fit (Hybrid implementation fit) log_kdeg Boolean; TRUE, log(kdeg) estimates used PCA rather logit(fn). Currently compatible Fast_Fit","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/FnPCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating PCA plots with logit(fn) estimates — FnPCA","text":"ggplot2 object.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/FnPCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating PCA plots with logit(fn) estimates — FnPCA","text":"","code":"# \\donttest{ # Simulate data for 500 genes and 2 replicates sim <- Simulate_bakRData(500, nreps = 2)  # Fit data with fast implementation Fit <- bakRFit(sim$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0500 #> 2     1     2 0.0502 #> 3     2     1 0.0500 #> 4     2     2 0.0500 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.00100239690833896 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # Fn PCA FnPCA(Fit$Fast_Fit)   # log(kdeg) PCA FnPCA(Fit$Fast_Fit, log_kdeg = TRUE)   # }"},{"path":"https://simonlabcode.github.io/bakR/reference/Heatmap_kdeg.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating a L2FC(kdeg) matrix that can be passed to heatmap functions — Heatmap_kdeg","title":"Creating a L2FC(kdeg) matrix that can be passed to heatmap functions — Heatmap_kdeg","text":"Heatmap_kdeg creates matrix column represents pair samples (reference experimental) row represents feature. entry ith row jth column L2FC(kdeg) feature comparing sample experimental ID j+1 reference sample","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Heatmap_kdeg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating a L2FC(kdeg) matrix that can be passed to heatmap functions — Heatmap_kdeg","text":"","code":"Heatmap_kdeg(obj, zscore = FALSE, filter_sig = FALSE, FDR = 0.05)"},{"path":"https://simonlabcode.github.io/bakR/reference/Heatmap_kdeg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating a L2FC(kdeg) matrix that can be passed to heatmap functions — Heatmap_kdeg","text":"obj Object outputted bakRFit zscore Logical; TRUE, matrix entry log-odds fold change fraction new (.k.effect size) divided uncertainty effect size filter_sig Logical; TRUE, features statistically significant L2FC(kdeg) least one comparison kept FDR Numeric; False discovery control filter_sig TRUE.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Heatmap_kdeg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating a L2FC(kdeg) matrix that can be passed to heatmap functions — Heatmap_kdeg","text":"matrix. Rows represent transcripts differentially expressed columns represent (left right) differential kinetics z-score, differential expression z-score, mechanism score positive represents synthesis driven negative degradation driven changes expression.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Heatmap_kdeg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating a L2FC(kdeg) matrix that can be passed to heatmap functions — Heatmap_kdeg","text":"","code":"# \\donttest{ # Simulate data sim <- Simulate_bakRData(1000)  # Fit data with fast implementation Fit <- bakRFit(sim$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 6 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0501 #> 2     1     2 0.0499 #> 3     1     3 0.0501 #> 4     2     1 0.0499 #> 5     2     2 0.0501 #> 6     2     3 0.0501 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.00100208181425541 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # L2FC(kdeg) heatmap matrix L2FC_kdeg_heat <- Heatmap_kdeg(Fit$Fast_Fit)  # }"},{"path":"https://simonlabcode.github.io/bakR/reference/NSSHeat.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct heatmap for non-steady state (NSS) analysis — NSSHeat","title":"Construct heatmap for non-steady state (NSS) analysis — NSSHeat","text":"uses output bakR differential expression analysis software construct dataframe can passed pheatmap::pheatmap(). heatmap display result steady-state quasi-independent analysis NR-seq data.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/NSSHeat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct heatmap for non-steady state (NSS) analysis — NSSHeat","text":"","code":"NSSHeat(   bakRFit,   DE_df,   bakRModel = c(\"MLE\", \"Hybrid\", \"MCMC\"),   DE_cutoff = 0.05,   bakR_cutoff = 0.05,   Exp_ID = 2,   lid = 4 )"},{"path":"https://simonlabcode.github.io/bakR/reference/NSSHeat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct heatmap for non-steady state (NSS) analysis — NSSHeat","text":"bakRFit bakRFit object DE_df dataframe required format differential expression analysis results. See -Analyses vignette details dataframe look like bakRModel Model fit bakR implementation used? Options MLE, Hybrid, MCMC DE_cutoff padj cutoff calling gene differentially expressed bakR_cutoff padj cutoff calling fraction new significantly changed Exp_ID Exp_ID experimental sample whose comparison reference sample want use. one reference vs. experimental sample comparison can used time lid Maximum absolute value standardized score present output. improving aesthetics heatmap generated output.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/NSSHeat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct heatmap for non-steady state (NSS) analysis — NSSHeat","text":"returns data frame can passed pheatmap::pheatmap()","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/NSSHeat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct heatmap for non-steady state (NSS) analysis — NSSHeat","text":"","code":"# \\donttest{ # Simulate small dataset sim <- Simulate_bakRData(100, nreps = 2)  # Analyze data with bakRFit Fit <- bakRFit(sim$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0499 #> 2     1     2 0.0505 #> 3     2     1 0.0499 #> 4     2     2 0.0495 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.0010062089557678 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # Number of features that made it past filtering NF <- nrow(Fit$Fast_Fit$Effects_df)  # Simulate mock differential expression data frame DE_df <- data.frame(XF = as.character(1:NF),                        log2FoldChange = stats::rnorm(NF, 0, 2))  DE_df$stat <- DE_df$log2FoldChange/0.5  DE_df$padj <- 2*stats::dnorm(-abs(DE_df$stat))  # make heatmap matrix Heatmap <- NSSHeat(bakRFit = Fit,                DE_df = DE_df,                bakRModel = \"MLE\")  # }"},{"path":"https://simonlabcode.github.io/bakR/reference/Simulate_bakRData.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulating nucleotide recoding data — Simulate_bakRData","title":"Simulating nucleotide recoding data — Simulate_bakRData","text":"Simulate_bakRData simulates bakRData object. output also includes simulated values kinetic parameters interest. number genes (ngene) set user, extensive list additional parameters can adjusted.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Simulate_bakRData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulating nucleotide recoding data — Simulate_bakRData","text":"","code":"Simulate_bakRData(   ngene,   num_conds = 2L,   nreps = 3L,   eff_sd = 0.75,   eff_mean = 0,   fn_mean = 0,   fn_sd = 1,   kslog_c = 0.8,   kslog_sd = 0.95,   tl = 60,   p_new = 0.05,   p_old = 0.001,   read_lengths = 200L,   p_do = 0,   noise_deg_a = -0.3,   noise_deg_b = -1.5,   noise_synth = 0.1,   sd_rep = 0.05,   low_L2FC_ks = -1,   high_L2FC_ks = 1,   num_kd_DE = c(0L, as.integer(rep(round(as.integer(ngene)/2), times =     as.integer(num_conds) - 1))),   num_ks_DE = rep(0L, times = as.integer(num_conds)),   scale_factor = 150,   sim_read_counts = TRUE,   a1 = 5,   a0 = 0.01,   nreads = 50L,   alpha = 25,   beta = 75,   STL = FALSE,   STL_len = 40 )"},{"path":"https://simonlabcode.github.io/bakR/reference/Simulate_bakRData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulating nucleotide recoding data — Simulate_bakRData","text":"ngene Number genes simulate data num_conds Number experimental conditions (including reference condition) simulate nreps Number replicates simulate eff_sd Effect size; specifically, standard deviation normal distribution non-zero changes logit(fraction new) pulled . eff_mean Effect size mean; mean normal distribution non-zero changes logit(fraction new) pulled . Note, setting 0 mean significant effect sizes 0, exact integer impossible draw continuous random number generator. Setting 0 just means symmetric stabilization destabilization fn_mean Mean fraction news simulated transcripts reference condition. logit(fraction) RNA transcript metabolically labeled (new) drawn normal distribution mean fn_sd Standard deviation fraction news simulated transcripts reference condition. logit(fraction) RNA transcript metabolically labeled (new) drawn normal distribution sd kslog_c Synthesis rate constants drawn lognormal distribution meanlog = kslog_c - mean(log(kd_mean)) kd_mean determined fraction new simulated gene well label time (tl). kslog_sd Synthesis rate lognormal standard deviation; see kslog_c documentation details tl metabolic label feed time p_new metabolic label (e.g., s4U) induced mutation rate. Can vector length num_conds p_old background mutation rate read_lengths Total read length sequencing read (e.g., PE100 reads correspond read_lengths = 200) p_do Rate metabolic label containing reads lost due dropout; must 0 1 noise_deg_a Slope trend relating log10(standardized read counts) log(replicate variability) noise_deg_b Intercept trend relating log10(standardized read counts) log(replicate variability) noise_synth Homoskedastic variability L2FC(ksyn) sd_rep Variance lognormal distribution replicate variability drawn low_L2FC_ks negative L2FC(ksyn) can simulated high_L2FC_ks positive L2FC(ksyn) can simulated num_kd_DE Vector element represents number genes show significant change stability relative reference. 1st entry must 0 definition (since relative reference reference sample unchanged) num_ks_DE num_kd_DE significant changes synthesis rates. scale_factor Factor relating RNA concentration (arbitrary units) average number read counts sim_read_counts Logical; TRUE, read counts simulated coming heterodisperse negative binomial distribution a1 Heterodispersion 1/reads dependence parameter a0 High read depth limit negative binomial dispersion parameter nreads Number reads simulated sim_read_counts FALSE alpha shape1 parameter beta distribution U-contents (probability nucleotide read transcript U) drawn gene. beta shape2 parameter beta distribution U-contents (probability nucleotide read transcript U) drawn gene. STL logical; TRUE, simulation STL-seq rather standard TL-seq experiment. two big changes short read length required (< 60 nt) every read particular feature number Us. one read length simulated simplicity. STL_len Average length simulated STL-seq length. Since Pol II typically pauses 20-60 bases promoter, around 40","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Simulate_bakRData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulating nucleotide recoding data — Simulate_bakRData","text":"list containing simulated bakRData object well list simulated kinetic parameters interest. contents latter list : Effect_sim; Dataframe meant mimic formatting Effect_df part bakRFit(StanFit = TRUE), bakRFit(HybridFit = TRUE) bakRFit(bakRData object) output. Fn_mean_sim; Dataframe meant mimic formatting Regularized_ests part bakRFit(bakRData object) output. Contains information true fraction new simulated condition (mean normal distribution replicate fraction news simulated) Fn_rep_sim; Dataframe meant mimic formatting Fn_Estimates part \\codebakRFit(bakRData object) output. Contains information fraction new simulated feature replicate condition. L2FC_ks_mean; true L2FC(ksyn) feature experimental condition. -th column corresponds L2FC(ksyn) comparing -th condition reference condition (defined 1st condition) 1st column always 0s RNA_conc; average number normalized read counts expected feature sample.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Simulate_bakRData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulating nucleotide recoding data — Simulate_bakRData","text":"Simulate_bakRData simulates bakRData object using realistic generative model many adjustable parameters. Average RNA kinetic parameters drawn biologically inspired distributions. Replicate variability simulated drawing feature's fraction new given replicate logit-Normal distribution heteroskedastic variance term average magnitude given chosen read count vs. variance relationship. replicate, feature's ksyn drawn homoskedastic lognormal distribution. Read counts can either set value simulated features can simulated according heterodisperse negative binomial distribution. latter default number Us sequencing read drawn binomial distribution number trials equal read length probability nucleotide U drawn beta distribution. read assigned new old population according Bernoulli distribution p = fraction new. number mutations read drawn one two binomial distributions; read assigned population new RNA, number mutations drawn binomial distribution number trials equal number Us probability mutation = p_new; read assigned population old RNA, number mutations instead drawn binomial distribution number trials probability mutation = p_old. p_new must greater p_old mutations new RNA arise background mutations occur probability p_old well metabolic label induced mutations Simulated read counts treated spike-RPKM normalized, scale factor can applied sample comparing sequencing reads (e.g., performing differential expression analysis). Function simulate bakRData object according realistic generative model","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/Simulate_bakRData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulating nucleotide recoding data — Simulate_bakRData","text":"","code":"# \\donttest{ # 2 replicate, 2 experimental condition, 1000 gene simulation sim_2reps <- Simulate_bakRData(ngene = 1000, nreps = 2)  # 3 replicate, 2 experimental condition, 1000 gene simulation # with 100 instances of differential degradation kinetics sim_3reps <- Simulate_bakRData(ngene = 1000, num_kd_DE = c(0, 100))  # 2 replicates, 3 experimental condition, 1000 gene simulation # with 100 instances of differential degradation kinetics in the 1st # condition and no instances of differential degradation kinetics in the # 2nd condition sim_3es <- Simulate_bakRData(ngene = 1000,                              nreps = 2,                              num_conds = 3,                              num_kd_DE = c(0, 100, 0))  # }"},{"path":"https://simonlabcode.github.io/bakR/reference/TL_stan.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit 'Stan' models to nucleotide recoding RNA-seq data analysis — TL_stan","title":"Fit 'Stan' models to nucleotide recoding RNA-seq data analysis — TL_stan","text":"TL_stan internal function analyze nucleotide recoding RNA-seq data fully Bayesian hierarchical model implemented PPL Stan. TL_stan estimates kinetic parameters differences kinetic parameters experimental conditions. assessing differences, single reference sample compared collection experimental samples provided.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/TL_stan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit 'Stan' models to nucleotide recoding RNA-seq data analysis — TL_stan","text":"","code":"TL_stan(   data_list,   Hybrid_Fit = FALSE,   keep_fit = FALSE,   NSS = FALSE,   chains = 1,   ... )"},{"path":"https://simonlabcode.github.io/bakR/reference/TL_stan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit 'Stan' models to nucleotide recoding RNA-seq data analysis — TL_stan","text":"data_list List pass 'Stan' form given cBprocess Hybrid_Fit Logical; TRUE, Hybrid 'Stan' model takes data output fast_analysis run. keep_fit Logical; TRUE, 'Stan' fit object included output; typically large file default FALSE. NSS Logical; TRUE, models directly compare logit(fn)s used avoid steady-state assumption chains Number Markov chains sample . default run single chain. Typical NR-seq datasets yield memory intensive analyses, running single chain decrease burden. reference, running MCMC implementation (Hybrid_Fit = FALSE) 3 chains NR-seq dataset 3 replicates 2 experimental conditions around 20 million raw (unmapped) reads per sample requires 100 GB RAM. single chain, burden drops around 20 GB. Due memory demands time constraints (runtimes MCMC implementation border likely around 1-2 days) means models usually run specialized High Performance Computing (HPC) system. ... Arguments passed rstan::sampling (e.g. iter, warmup, etc.).","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/TL_stan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit 'Stan' models to nucleotide recoding RNA-seq data analysis — TL_stan","text":"list objects: Effects_df; dataframe estimates effect size (change logit(fn)) comparing experimental condition reference sample feature. dataframe also includes p-values obtained moderated t-test. columns dataframe : Feature_ID; Numerical ID feature Exp_ID; Numerical ID experimental condition (Exp_ID metadf) L2FC_kdeg; L2FC(kdeg) posterior mean L2FC_kd_sd; L2FC(kdeg) posterior sd effect; identical L2FC_kdeg (kept symmetry MLE fit output) se; identical L2FC_kd_sd (kept symmetry MLE fit output) XF; Feature name pval; p value obtained effect se + z-test padj; p value adjusted multiple testing using Benjamini-Hochberg procedure Kdeg_df; dataframe estimates kdeg (RNA degradation rate constant) feature, averaged across replicate data. columns dataframe : Feature_ID; Numerical ID feature Exp_ID; Numerical ID experimental condition kdeg; Degradation rate constant posterior mean kdeg_sd; Degradation rate constant posterior standard deviation XF; Original feature name Fn_Estimates; dataframe estimates logit(fraction new) feature replicate. columns dataframe : Feature_ID; Numerical ID feature Exp_ID; Numerical ID experimental condition (Exp_ID metadf) Replicate; Numerical ID replicate logit_fn; Logit(fraction new) posterior mean logit_fn_se; Logit(fraction new) posterior standard deviation sample; Sample name XF; Original feature name Fit_Summary; outputted keep_fit == FALSE. Summary 'Stan' fit object row corresponding particular parameter. posterior point descriptions descriptions marginal posterior distribution parameter row. example, posterior mean average value parameter averaging parameter values. columns dataframe : mean; Posterior mean parameter given row name se_mean; Standard error posterior mean; essentially confident model estimates posterior mean posterior mean actually . depend number chains run number iterations chain run . sd; Posterior standard deviation 2.5%; 2.5th percentile posterior distribution. 2.5% posterior mass point 25%; 25th percentile posterior distribution 50%; 50th percentile posterior distribution 75%; 75th percentile posterior distribution 97.5%; 97.5th percentile posterior distribution n_eff; Effective sample size. larger better, though preferably around total number iterations (iter x chains). Small values represent poor model convergence Rhat; Describes well separate Markov chains mixed. preferably close 1 possible, values higher 1 represent poor model convergence Stan_Fit; outputted keep_fit == TRUE. full 'Stan' fit object, R6 object class stanfit Mutation_Rates; data frame information mutation rate estimates. columns Fit_Summary. row corresponds either background mutation rate (log_lambda_o) s4U induced mutation rate (log_lambda_n), denoted parameter column. bracketed portion parameter name contain two numbers. first corresponds Exp_ID second corresponds Replicate_ID. example, parameter name log_lambda_o[1,2] row corresponds background mutation rate second replicate experimental condition one. final point mention estimates log(avg. # mutations) scale. log_lambda_n 1 means average, estimated 2.72 (exp(1)) mutations reads new RNA (.e., RNA synthesized s4U labeling).","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/TL_stan.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit 'Stan' models to nucleotide recoding RNA-seq data analysis — TL_stan","text":"Two implementations similar model can fit TL_stan: complete nucleotide recoding RNA-seq analysis hybrid analysis takes input results fast_analysis. complete analysis (referred bakR publication MCMC implementation), U--C mutations modeled coming Poisson distribution rate parameter adjusted empirical U-content feature analyzed. Features represent whatever user defined constructing bakR data object. Typical feature categories genes, exons, etc. Hierarchical modeling used pool data across replicates, across features, across replicates. specifically, replicate data feature partially pooled estimate feature-specific mean fraction news uncertainties. Feature means partially pooled estimate dataset-wide mean fraction news standard deviations. replicate variability feature also partially pooled determine condition-wide heteroskedastic relationship read depths replicate variability. Partial pooling reduces subjectivity determining priors allowing model determine priors make sense given data. Partial pooling also regularizes estimates, reducing estimate variability thus increasing estimate accuracy. particularly important replicate variability estimates, often rely replicates data per feature thus typically highly unstable. hybrid analysis (referred bakR publication Hybrid implementation) inherits hierarchical modeling structure complete analysis, reduces computational burden foregoing per-replicate--feature fraction new estimation uncertainty quantification. Instead, hybrid analysis takes data fraction new estimates approximate uncertainties fast_analysis. Runtimes hybrid analysis thus often order magnitude shorter complete analysis, loses accuracy relying point estimates uncertainty quantification valid limit large dataset sizes (dataset size per-replicate--feature fraction new estimate raw number sequencing reads mapping feature replicate). Users also option save discard 'Stan' fit object. Fit objects can exceedingly large (> 10 GB) nucleotide recoding RNA-seq datasets. Therefore, want store large object, summary object saved instead, greatly reduces size output (~ 10-50 MB) still retaining much important information. addition, output TL_stan provides estimates uncertainties key parameters (L2FC(kdeg), kdeg, fraction new) likely interest. said, analyses possible original fit object saved. example, fit object contain samples posterior collected model fitting. Thus, new parameters (e.g., L2FC(kdeg)'s comparing two experimental samples) naturally generated model can estimated post-hoc. Still, often approximate estimates can obtained parameters rely full fit object. One analysis impossible without original fit object generating model diagnostic plots. include trace plots (show mixing efficient parameter space exploration Markov chains), pairs plots (show correlations parameters divergences occurred), visualizations can help users assess well model ran. models implemented TL_stan extensively validated, less likely diagnostics helpful, often anomalies data can lead poor model convergence, case assessing model diagnostics can help identify source problems data. Summary statistics describing well model able estimate parameter (n_eff rhat) provided fit summaries, can often obscure nuanced details model fitting.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The 'bakR' package. — bakR-package","title":"The 'bakR' package. — bakR-package","text":"DESCRIPTION PACKAGE","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakR-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The 'bakR' package. — bakR-package","text":"Stan Development Team (2020). RStan: R interface Stan. R package version 2.21.2. https://mc-stan.org","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRData.html","id":null,"dir":"Reference","previous_headings":"","what":"bakR Data object helper function for users — bakRData","title":"bakR Data object helper function for users — bakRData","text":"function creates object class bakRData","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bakR Data object helper function for users — bakRData","text":"","code":"bakRData(cB, metadf)"},{"path":"https://simonlabcode.github.io/bakR/reference/bakRData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bakR Data object helper function for users — bakRData","text":"cB Dataframe columns corresponding feature ID, number Ts, number mutations, sample ID, number identical observations metadf Dataframe detailing s4U label time experimental ID sample","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bakR Data object helper function for users — bakRData","text":"bakRData object. two components: data frame describing experimental details (metadf) data frame containing NR-seq data (cB).","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bakR Data object helper function for users — bakRData","text":"","code":"# Load cB data(\"cB_small\")  # Load metadf data(\"metadf\")  # Create bakRData object bakRData <- bakRData(cB_small, metadf)"},{"path":"https://simonlabcode.github.io/bakR/reference/bakRFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","title":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","text":"bakRFit analyzes nucleotide recoding RNA-seq data estimate kinetic parameters relating RNA stability changes RNA stability induced experimental perturbations. Several statistical models varying efficiency accuracy can used fit data.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","text":"","code":"bakRFit(   obj,   StanFit = FALSE,   HybridFit = FALSE,   high_p = 0.2,   totcut = 50,   Ucut = 0.25,   AvgU = 4,   FastRerun = FALSE,   FOI = c(),   concat = TRUE,   StanRateEst = FALSE,   RateEst_size = 25,   low_reads = 1000,   high_reads = 5000,   chains = 1,   NSS = FALSE,   Chase = FALSE,   BDA_model = FALSE,   ... )"},{"path":"https://simonlabcode.github.io/bakR/reference/bakRFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","text":"obj bakRData object produced bakRData bakRFit object produced bakRFit StanFit Logical; TRUE, MCMC implementation run. used obj bakRFit object HybridFit Logical; TRUE, Hybrid implementation run. used obj bakRFit object high_p Numeric; transcripts mutation rate (number mutations / number Ts reads) higher -s4U control samples (.e., samples treated s4U) filtered totcut Numeric; transcripts less number sequencing reads sample filtered Ucut Numeric; transcripts must fraction reads 2 less Us less cutoff samples AvgU Numeric; transcripts must average number Us greater cutoff samples FastRerun Logical; matters bakRFit object passed bakRFit. TRUE, Stan-free model implemented fast_analysis rerun data, foregoing fitting either 'Stan' models. FOI Features interest; character vector containing names features analyze concat Logical; TRUE, FOI concatenated output reliableFeatures StanRateEst Logical; TRUE, simple 'Stan' model used estimate mutation rates fast_analysis; may add couple minutes runtime analysis. RateEst_size Numeric; StanRateEst TRUE, data RateEst_size genes used mutation rate estimation. can low 1 kept low ensure maximum efficiency low_reads Numeric; StanRateEst TRUE, features low_reads reads samples used mutation rate estimation high_reads Numeric; StanRateEst TRUE, features less high_read reads samples used mutation rate estimation. high read count cutoff important low read count cutoff case want fraction labeled chosen features extreme (e.g., close 0 1), high read count features likely low fraction new features. chains Number Markov chains sample . 1 suffice since validated models. Running chains generally preferable, memory constraints can make unfeasible. NSS Logical; TRUE, logit(fn)s directly compared avoid assuming steady-state Chase Logical; Set TRUE analyzing pulse-chase experiment. TRUE, kdeg = -ln(fn)/tl fn fraction reads s4U (properly referred fraction old context pulse-chase experiment). BDA_model Logical; TRUE, variance regularized scaled inverse chi-squared model. Otherwise log-normal model used. ... Arguments passed either fast_analysis (bakRData object) TL_Stan Hybrid_fit (bakRFit object)","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","text":"bakRFit object results statistical modeling data processing. Objects possibly included : Fast_Fit; Always present. Output fast_analysis Hybrid_Fit; present HybridFit = TRUE. Output TL_stan Stan_Fit; present StanFit = TRUE. Output TL_stan Data_lists; Always present. Output cBprocess Fast Stan == TRUE","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRFit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","text":"bakRFit run bakRData object, cBprocess fast_analysis always called. former generate processed data can passed model fitting functions (fast_analysis TL_Stan). call fast_analysis generate list dataframes containing information regarding fast_analysis fit. fast_analysis always called output required Hybrid_fit TL_Stan. bakRFit run bakRFit object, cBprocess called , output cBprocess already contained bakRFit object. Similarly, fast_analysis called unless bakRFit rerun bakRData object. FastRerun set TRUE. want generate model fits using different parameters cBprocess, rerun bakRFit bakRData object. See documentation individual fitting functions details regarding analyze nucleotide recoding data. follows brief overview works fast_analysis (referred MLE implementation bakR paper) either estimates mutation rates + (available) - s4U samples uses mutation rate estimates provided user perform maximum likelihood estimation (MLE) fraction RNA labeled replicate nucleotide recoding data provided. Uncertainties replicate's estimate approximated using asymptotic results involving Fisher Information assuming known mutation rates. Replicate data pooled using approximation hierarchical modeling relies analytic solutions simple Bayesian models. Linear regression used estimate relationship read depths replicate variability uncertainty estimation regularization, performed using analytic solutions Bayesian models. TL_Stan Hybrid_Fit set TRUE (referred Hybrid implementation bakR paper) takes input estimates logit(fraction new) uncertainty provided fast_analysis. uses 'Stan' backend implement hierarchical model pools data across replicates dataset estimate effect sizes (L2FC(kdeg)) uncertainties. Replicate variability information pooled across experimental condition regularize variance estimates using hierarchical linear regression model. default behavior TL_Stan (referred MCMC implementation bakR paper) use 'Stan' back end implement U-content exposure adjusted Poisson mixture model estimate fraction news mutational data. Partial pooling replicate variability estimates performed Hybrid implementation.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/bakRFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating kinetic parameters from nucleotide recoding RNA-seq data — bakRFit","text":"","code":"# \\donttest{ # Simulate data for 1000 genes, 2 replicates, 2 conditions simdata <- Simulate_bakRData(1000, nreps = 2)  # You always must fit fast implementation before any others Fit <- bakRFit(simdata$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0499 #> 2     1     2 0.0500 #> 3     2     1 0.0500 #> 4     2     2 0.0501 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.000999686205764166 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # }"},{"path":"https://simonlabcode.github.io/bakR/reference/cB_small.html","id":null,"dir":"Reference","previous_headings":"","what":"Example cB data frame — cB_small","title":"Example cB data frame — cB_small","text":"Subset cB file DCP2 dataset published Luo et al. 2020. original file large (69 MB), example cB file downsampled contains 10 genes (rather 25012). columns described Getting_Started vignette.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cB_small.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example cB data frame — cB_small","text":"","code":"data(cB_small)"},{"path":"https://simonlabcode.github.io/bakR/reference/cB_small.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example cB data frame — cB_small","text":"dataframe 5788 rows 5 variables; row corresponds group sequencing reads sample Sample name TC Number T--C mutations nT Number Ts XF Name feature group reads map; usually gene name n Number identical sequencing reads","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cB_small.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example cB data frame — cB_small","text":"Luo et al. (2020) Biochemistry. 59(42), 4121-4142","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cB_small.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example cB data frame — cB_small","text":"","code":"data(cB_small) data(metadf) bakRdat <- bakRData(cB_small, metadf)"},{"path":"https://simonlabcode.github.io/bakR/reference/cBprocess.html","id":null,"dir":"Reference","previous_headings":"","what":"Curate data in bakRData object for statistical modeling — cBprocess","title":"Curate data in bakRData object for statistical modeling — cBprocess","text":"cBprocess creates data structures necessary analyze nucleotide recoding RNA-seq data statistical model implementations bakRFit. input cBprocess must object class bakRData. output can contain data passable fast_analysis (Fast == TRUE), TL_stan StanFit = TRUE Stan == TRUE, .","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cBprocess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Curate data in bakRData object for statistical modeling — cBprocess","text":"","code":"cBprocess(   obj,   high_p = 0.2,   totcut = 50,   Ucut = 0.25,   AvgU = 4,   Stan = TRUE,   Fast = TRUE,   FOI = c(),   concat = TRUE )"},{"path":"https://simonlabcode.github.io/bakR/reference/cBprocess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Curate data in bakRData object for statistical modeling — cBprocess","text":"obj object class bakRData high_p Numeric; transcripts mutation rate (number mutations / number Ts reads) higher s4U control samples filtered totcut Numeric; transcripts less number sequencing reads sample filtered Ucut Numeric; transcripts must fraction reads 2 less Us less cutoff samples AvgU Numeric; transcripts must average number Us greater cutoff samples Stan Boolean; TRUE, data_list can passed 'Stan' curated Fast Boolean; TRUE, dataframe can passed fast_analysis() curated FOI Features interest; character vector containing names features analyze concat Boolean; TRUE, FOI concatenated output reliableFeatures","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cBprocess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Curate data in bakRData object for statistical modeling — cBprocess","text":"returns list objects can passed TL_stan /fast_analysis. objects : Stan_data; list can passed TL_stan Hybrid_Fit = FALSE. Consists metadata well data 'Stan' analyze. Data analyzed consists equal length vectors. contents Stan_data : NE; Number datapoints 'Stan' analyze (NE = Number Elements) NF; Number features dataset TP; Numerical indicator s4U feed (0 = s4U feed, 1 = s4U fed) FE; Numerical indicator feature num_mut; Number U--C mutations observed particular set reads MT; Numerical indicator experimental condition (Exp_ID metadf) nMT; Number experimental conditions R; Numerical indicator replicate nrep; Number replicates (analysis requires number replicates conditions) num_obs; Number reads identical data (number mutations, feature origin, sample origin) tl; Vector label times experimental condition U_cont; Log2-fold-difference U-content feature sample relative average U-content sample Avg_Reads; Standardized log10(average read counts) particular feature particular condition, averaged replicates Avg_Reads_natural; Unstandardized average read counts particular feature particular condition, averaged replicates. Used plotMA sdf; Dataframe maps numerical feature ID original feature name. Also read depth information sample_lookup; Lookup table relating MT R original sample name Fast_df; data frame can passed fast_analysis. contents Fast_df : sample; Original sample name XF; Original feature name TC; Number T C mutations nT; Number Ts read n; Number identical observations fnum; Numerical indicator feature type; Numerical indicator s4U feed (0 = s4U feed, 1 = s4U fed) mut; Numerical indicator experimental condition (Exp_ID metadf) reps; Numerical indicator replicate Count_Matrix; matrix read count information. column represents sample row represents feature. entry raw number read counts mapping particular feature particular sample. Column names corresponding sample names row names corresponding feature names.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cBprocess.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Curate data in bakRData object for statistical modeling — cBprocess","text":"1st step executed cBprocess find names features deemed \"reliable\". reliable feature one sufficient read coverage every single sample (.e., > totcut reads samples) limited mutation content -s4U control samples (.e., < high_p mutation rate samples lacking s4U feeds). done call reliableFeatures. 2nd step extract reliableFeatures cB dataframe bakRData object. process, numerical ID given reliableFeature, numerical ID corresponding order feature found original cB (might typically alphabetical order). 3rd step prepare dataframe row corresponds set n identical reads (come sample number mutations Us). Part process involves assigning arbitrary numerical ID replicate experimental condition. numerical ID correspond order sample appears metadf. outcome step multiple dataframes variable information content. include dataframe information read counts sample, one logs U-contents feature, one compatible fast_analysis thus groups reads number mutations well number Us, one compatible TL_stan StanFit == TRUE thus groups ready number mutations. end step, two smaller data structures created, one average count matrix (count matrix ith row jth column corresponds average number reads mappin feature experimental condition j, averaged replicates) sample lookup table relates numerical experimental replicate IDs original sample name. FOI non-null concat == TRUE, features listed FOI included list reliable features make past filtering. FOI non-null concat == FALSE, features listed FOI reliable features make past filtering. FOI null concat == FALSE, error thrown.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/cBprocess.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Curate data in bakRData object for statistical modeling — cBprocess","text":"","code":"# \\donttest{  # Load cB data(\"cB_small\")  # Load metadf data(\"metadf\")  # Create bakRData bakRData <- bakRData(cB_small, metadf)  # Preprocess data data_for_bakR <- cBprocess(obj = bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... # }"},{"path":"https://simonlabcode.github.io/bakR/reference/fast_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Efficiently analyze nucleotide recoding data — fast_analysis","title":"Efficiently analyze nucleotide recoding data — fast_analysis","text":"fast_analysis analyzes nucleotide recoding data maximum likelihood estimation L-BFGS-B algorithm implemented stats::optim combined analytic solutations simple Bayesian models perform approximate partial pooling. Output includes kinetic parameter estimates replicate, kinetic parameter estimates averaged across replicates, log-2 fold changes degradation rate constant (L2FC(kdeg)). Averaging takes account uncertainties estimated using Fisher Information estimates regularized using analytic solutions fully Bayesian models. result kdegs shrunk towards population means uncertainties shrunk towards mean-variance trend estimated part analysis.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/fast_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Efficiently analyze nucleotide recoding data — fast_analysis","text":"","code":"fast_analysis(   df,   pnew = NULL,   pold = NULL,   no_ctl = FALSE,   read_cut = 50,   features_cut = 50,   nbin = NULL,   prior_weight = 2,   MLE = TRUE,   lower = -7,   upper = 7,   se_max = 2.5,   mut_reg = 0.1,   p_mean = 0,   p_sd = 1,   StanRate = FALSE,   Stan_data = NULL,   null_cutoff = 0,   NSS = FALSE,   Chase = FALSE,   BDA_model = FALSE )"},{"path":"https://simonlabcode.github.io/bakR/reference/fast_analysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Efficiently analyze nucleotide recoding data — fast_analysis","text":"df Dataframe form provided cB_to_Fast pnew Labeled read mutation rate; default 0 means model estimates rate s4U fed data. pnew provided user, must  vector length == number s4U fed samples. 1st element corresponds s4U induced mutation rate estimate 1st replicate 1st experimental condition; 2nd element corresponds s4U induced mutation rate estimate 2nd replicate 1st experimental condition, etc. pold Unlabeled read mutation rate; default 0 means model estimates rate -s4U fed data no_ctl Logical; TRUE, -s4U control used background mutation rate estimation read_cut Minimum number reads given feature-sample combo used mut rate estimates features_cut Number features estimate sample specific mutation rate nbin Number bins mean-variance relationship estimation. NULL, max 10 (number logit(fn) estimates)/100 used prior_weight Determines extent logit(fn) variance regularized mean-variance regression line MLE Logical; TRUE replicate logit(fn) estimated using maximum likelihood; FALSE conservative Bayesian hypothesis testing used lower Lower bound MLE L-BFGS-B algorithm upper Upper bound MLE L-BFGS-B algorithm se_max Uncertainty given transcripts estimates upper lower bound sets. prevents downstream errors due abnormally high standard errors due transcripts extreme kinetics mut_reg MLE instabilities, empirical mut rate used estimate fn, multiplying pnew 1+mut_reg pold 1-mut_reg regularize fn p_mean Mean normal distribution used prior penalty MLE logit(fn) p_sd Standard deviation normal distribution used prior penalty MLE logit(fn) StanRate Logical; TRUE, simple 'Stan' model used estimate mutation rates fast_analysis; may add couple minutes runtime analysis. Stan_data List; StanRate TRUE, data passed 'Stan' model estimate mutation rates. using bakRFit wrapper fast_analysis, created automatically. null_cutoff bakR test null hypothesis |effect size| < |null_cutoff| NSS Logical; TRUE, logit(fn)s compared rather log(kdeg) avoid steady-state assumption. Chase Logical; Set TRUE analyzing pulse-chase experiment. TRUE, kdeg = -ln(fn)/tl fn fraction reads s4U (properly referred fraction old context pulse-chase experiment) BDA_model Logical; TRUE, variance regularized scaled inverse chi-squared model. Otherwise log-normal model used.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/fast_analysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Efficiently analyze nucleotide recoding data — fast_analysis","text":"List dataframes providing information replicate-specific pooled analysis results. output includes: Fn_Estimates; dataframe estimates fraction new fraction new uncertainty feature replicate. columns dataframe : Feature_ID; Numerical ID feature Exp_ID; Numerical ID experimental condition (Exp_ID metadf) Replicate; Numerical ID replicate logit_fn; logit(fraction new) estimate, unregularized logit_fn_se; logit(fraction new) uncertainty, unregularized obtained Fisher Information nreads; Number reads mapping feature sample estimates obtained log_kdeg; log degradation rate constant (kdeg) estimate, unregularized kdeg; degradation rate constant (kdeg) estimate log_kd_se; log(kdeg) uncertainty, unregularized obtained Fisher Information sample; Sample name XF; Original feature name Regularized_ests; dataframe average fraction new kdeg estimates, averaged across replicates regularized using priors informed entire dataset. columns dataframe : Feature_ID; Numerical ID feature Exp_ID; Numerical ID experimental condition (Exp_ID metadf) avg_log_kdeg; Weighted average log(kdeg) replicate, weighted sample feature-specific read depth sd_log_kdeg; Standard deviation log(kdeg) estimates nreads; Total number reads mapping feature condition sdp; Prior standard deviation fraction new estimate regularization theta_o; Prior mean fraction new estimate regularization sd_post; Posterior uncertainty log_kdeg_post; Posterior mean log(kdeg) estimate kdeg; exp(log_kdeg_post) kdeg_sd; kdeg uncertainty XF; Original feature name Effects_df; dataframe estimates effect size (change logit(fn)) comparing experimental condition reference sample feature. dataframe also includes p-values obtained moderated t-test. columns dataframe : Feature_ID; Numerical ID feature Exp_ID; Numerical ID experimental condition (Exp_ID metadf) L2FC(kdeg); Log2 fold change (L2FC) kdeg estimate change logit(fn) NSS TRUE effect; LFC(kdeg) se; Uncertainty L2FC_kdeg pval; P-value obtained using effect_size, se, z-test padj; pval adjusted multiple testing using Benjamini-Hochberg procedure XF; Original feature name Mut_rates; list two elements. 1st element dataframe s4U induced mutation rate estimates, mut column represents experimental ID rep column represents replicate ID. 2nd element single background mutation rate estimate used Hyper_Parameters; vector two elements, named b. hyperparameters estimated uncertainties feature, represent two parameters Scaled Inverse Chi-Square distribution. Importantly, number additional degrees freedom provided sharing uncertainty information across dataset, used moderated t-test. Mean_Variance_lms; linear model objects obtained uncertainty vs. read count regression model. One model run Exp_ID","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/fast_analysis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Efficiently analyze nucleotide recoding data — fast_analysis","text":"Unless user supplies estimates pnew pold, first step fast_analysis estimate background metabolic label (refer s4U simplicity, though bakR compatible metabolic labels s6G) induced mutation rates. former best performed -s4U control sample, , normal RNA-seq sample lacks -s4U feed TimeLapse chemistry conversion s4U C analog. sample missing, background s4U induced mutation rates estimated s4U fed samples. s4U mutation rate, features sufficient read depth, defined read_cut parameter, highest mutation rates assumed completely labeled. Thus, average mutation rates features taken estimate s4U induced mutation rate sample. s4U induced mutation rates estimated per-sample basis often much variability mutation rates background mutation rates. -s4U control included, background mutation rate estimated using features control sample(s) read depths greater read_cut. average mutation rate among features taken estimated background mutation rate, background assumed constant samples. -s4U control missing, strategy similar used estimate s4U induced mutation rates used. case, lowest mutation rate features sufficient read depths used, average mutation rate background mutation rate estimate, features assumed almost entirely unlabeled. Another slightly computationally intensive accurate strategy estimate mutation rates set StanRate = TRUE. fit non-hierarchical mixture model small subset transcripts using 'Stan'. default bakRFit use 25 transcripts. StanRate TRUE, data list must passed Stan_data form appears bakRFit object's Data_list$Stan_data entry. mutation rates estimated, fraction news feature sample estimated. approach utilized MLE using L-BFGS-B algorithm implemented stats::optim. assumed likelihood function derived Poisson mixture model rates adjusted according feature's empirical U-content (average number Us present sequencing reads mapping feature particular sample). Fraction new estimates converted degradation rate constant estimates using solution simple ordinary differential equation model RNA metabolism. fraction new kdegs estimated, uncertainty parameters estimated using Fisher Information. limit large datasets, variance MLE inversely proportional Fisher Information evaluated MLE. Mixture models typically singular, meaning Fisher information matrix positive definite asymptotic results variance necessarily hold. mutation rates estimated priori fixed > 0, problems eliminated. addition, assessing uncertainty replicate fraction new estimates, size dataset raw number sequencing reads map particular feature. number often large (>100) increases validity invoking asymptotics. kdegs uncertainties estimated, replicate estimates pooled regularized. two key steps downstream analysis. 1st, uncertainty feature used fit linear ln(uncertainty) vs. log10(read depth) trend, uncertainties individual features shrunk towards regression line. uncertainty feature combination Fisher Information asymptotic uncertainty well amount variability seen estimates. Regularization uncertainty estimates performed using analytic results Normal distribution likelihood known mean unknown variance conjugate priors. prior parameters estimated regression amount variability regression line. strength regularization can tuned adjusting prior_weight parameter, larger numbers yielding stronger shrinkage towards regression line. 2nd step regularize average kdeg estimates. done using analytic results Normal distribution likelihood model unknown mean known variance conjugate priors. prior parameters estimated population wide kdeg distribution (using mean standard deviation mean standard deviation normal prior). 1st step, known mean assumed average kdeg, averaged across replicates weighted number reads mapping feature replicate. 2nd step, known variance assumed obtained following regularization uncertainty estimates. Effect sizes (changes kdeg) obtained difference log(kdeg) means reference experimental sample(s), log(kdeg)s assumed independent variance effect size sum log(kdeg) variances. P-values assessing significance effect size obtained using moderated t-test number degrees freedom determined uncertainty regression hyperparameters adjusted multiple testing using Benjamini- Hochberg procedure control false discovery rates (FDRs). cases, assumed ODE model RNA metabolism accurately model dynamics biological system analyzed. cases, best compare logit(fraction new)s directly rather converting fraction new log(kdeg). analysis strategy implemented NSS set TRUE. Comparing logit(fraction new) valid single metabolic label time used samples. example, label time 1 hour used NR-seq data WT cells 2 hour label time used KO cells, comparison longer valid differences logit(fraction new) stem differences kinetics label times.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/fast_analysis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Efficiently analyze nucleotide recoding data — fast_analysis","text":"","code":"# \\donttest{  # Simulate small dataset sim <- Simulate_bakRData(300, nreps = 2)  # Fit fast model to get fast_df Fit <- bakRFit(sim$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0500 #> 2     1     2 0.0501 #> 3     2     1 0.0501 #> 4     2     2 0.0500 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.00100100641092091 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # Fit fast model with fast_analysis Fast_Fit <- fast_analysis(Fit$Data_lists$Fast_df) #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0500 #> 2     1     2 0.0501 #> 3     2     1 0.0501 #> 4     2     2 0.0500 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.00100100641092091 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance # }"},{"path":"https://simonlabcode.github.io/bakR/reference/metadf.html","id":null,"dir":"Reference","previous_headings":"","what":"Example meatdf data frame — metadf","title":"Example meatdf data frame — metadf","text":"metadf dataframe describing data present cB file can loaded data(cB_small). contents discussed great detail Getting_started vignette.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/metadf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example meatdf data frame — metadf","text":"","code":"data(metadf)"},{"path":"https://simonlabcode.github.io/bakR/reference/metadf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example meatdf data frame — metadf","text":"dataframe 6 rows 2 variables: row names samples corresponding cB tl time s4U labeling, hours Exp_ID numerical ID reference experimental conditions; 1 reference 2 single experimental condition","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/metadf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example meatdf data frame — metadf","text":"","code":"data(cB_small) data(metadf) bakRdat <- bakRData(cB_small, metadf)"},{"path":"https://simonlabcode.github.io/bakR/reference/new_bakRData.html","id":null,"dir":"Reference","previous_headings":"","what":"bakRData object constructor for internal use — new_bakRData","title":"bakRData object constructor for internal use — new_bakRData","text":"function efficiently creates object class bakRData without performing rigorous checks","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/new_bakRData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bakRData object constructor for internal use — new_bakRData","text":"","code":"new_bakRData(cB, metadf)"},{"path":"https://simonlabcode.github.io/bakR/reference/new_bakRData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bakRData object constructor for internal use — new_bakRData","text":"cB Dataframe columns corresponding feature ID, number Ts, number mutations, sample ID, number identical observations metadf Dataframe detailing s4U label time experimental ID sample","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotMA.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating L2FC(kdeg) MA plot from fit objects — plotMA","title":"Creating L2FC(kdeg) MA plot from fit objects — plotMA","text":"function outputs L2FC(kdeg) MA plot. Plots colored according statistical significance sign L2FC(kdeg)","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotMA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating L2FC(kdeg) MA plot from fit objects — plotMA","text":"","code":"plotMA(   obj,   Model = c(\"MLE\", \"Hybrid\", \"MCMC\"),   FDR = 0.05,   Exps = NULL,   Exp_shape = FALSE )"},{"path":"https://simonlabcode.github.io/bakR/reference/plotMA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating L2FC(kdeg) MA plot from fit objects — plotMA","text":"obj Object class bakRFit outputted bakRFit function Model String identifying implementation want generate MA plot FDR False discovery rate control significance assessment Exps Vector Experimental IDs include plot; must contain elements within 2:(# experimental IDs) Exp_shape Logical indicating whether use Experimental ID factor determining point shape volcano plot","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotMA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating L2FC(kdeg) MA plot from fit objects — plotMA","text":"ggplot object. point represents transcript. x-axis log-10 transformed replicate average read counts, y-axis log-2 fold-change degradation rate constant.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotMA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating L2FC(kdeg) MA plot from fit objects — plotMA","text":"","code":"# \\donttest{ # Simulate data for 500 genes and 2 replicates sim <- Simulate_bakRData(500, nreps = 2)  # Fit data with fast implementation Fit <- bakRFit(sim$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0499 #> 2     1     2 0.0500 #> 3     2     1 0.0501 #> 4     2     2 0.0501 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.00100953328693925 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # Volcano plot plotMA(Fit, Model = \"MLE\")   # }"},{"path":"https://simonlabcode.github.io/bakR/reference/plotVolcano.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating L2FC(kdeg) volcano plot from fit objects — plotVolcano","title":"Creating L2FC(kdeg) volcano plot from fit objects — plotVolcano","text":"function creates L2FC(kdeg) volcano plot. Plots colored according statistical significance sign L2FC(kdeg).","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotVolcano.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating L2FC(kdeg) volcano plot from fit objects — plotVolcano","text":"","code":"plotVolcano(obj, FDR = 0.05, Exps = NULL, Exp_shape = FALSE)"},{"path":"https://simonlabcode.github.io/bakR/reference/plotVolcano.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating L2FC(kdeg) volcano plot from fit objects — plotVolcano","text":"obj Object contained within output bakRFit. , either Fast_Fit (MLE implementation fit), Stan_Fit (MCMC implementation fit), Hybrid_Fit (Hybrid implementation fit) FDR False discovery rate control significance assessment Exps Vector Experimental IDs include plot; must contain elements within 2:(# experimental IDs) Exp_shape Logical indicating whether use Experimental ID factor determining point shape volcano plot","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotVolcano.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating L2FC(kdeg) volcano plot from fit objects — plotVolcano","text":"ggplot object. point represents transcript. x-axis log-2 fold change degradation rate constant y-axis log-10 transformed multiple test adjusted p value.","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/plotVolcano.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating L2FC(kdeg) volcano plot from fit objects — plotVolcano","text":"","code":"# \\donttest{ # Simulate data for 500 genes and 2 replicates sim <- Simulate_bakRData(500, nreps = 2)  # Fit data with fast implementation Fit <- bakRFit(sim$bakRData) #> Finding reliable Features #> Filtering out unwanted or unreliable features #> Processing data... #> Estimating labeled mutation rate #> Estimated pnews for each sample are: #> # A tibble: 4 × 3 #> # Groups:   mut [2] #>     mut  reps   pnew #>   <int> <int>  <dbl> #> 1     1     1 0.0502 #> 2     1     2 0.0503 #> 3     2     1 0.0500 #> 4     2     2 0.0502 #> Estimating unlabeled mutation rate #> Estimated pold is:  0.000998424036099747 #> Estimating fraction labeled #> Estimating per replicate uncertainties #> Estimating read count-variance relationship #> Averaging replicate data and regularizing estimates #> Assessing statistical significance  # Volcano plot plotVolcano(Fit$Fast_Fit)   # }"},{"path":"https://simonlabcode.github.io/bakR/reference/reliableFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify features (e.g., transcripts) with high quality data — reliableFeatures","title":"Identify features (e.g., transcripts) with high quality data — reliableFeatures","text":"function identifies features (e.g., transcripts, exons, etc.) mutation rate set threshold control (s4U) sample reads set threshold samples. -s4U sample, read count cutoff considered. Additional filtering options relevant working short RNA-seq read data. includes filtering features extremely low empirical U-content (.e., average number Us sequencing reads feature) reads least 3 Us .","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/reliableFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify features (e.g., transcripts) with high quality data — reliableFeatures","text":"","code":"reliableFeatures(obj, high_p = 0.2, totcut = 50, Ucut = 0.25, AvgU = 4)"},{"path":"https://simonlabcode.github.io/bakR/reference/reliableFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify features (e.g., transcripts) with high quality data — reliableFeatures","text":"obj Object class bakRData high_p highest mutation rate accepted control samples totcut readcount cutoff Ucut Must fraction reads 2 less Us less cutoff samples AvgU Must average number Us greater ","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/reliableFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify features (e.g., transcripts) with high quality data — reliableFeatures","text":"vector gene names passed reliability filter","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/reliableFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify features (e.g., transcripts) with high quality data — reliableFeatures","text":"","code":"# \\donttest{  # Load cB data(\"cB_small\")  # Load metadf data(\"metadf\")  # Create bakRData bakRData <- bakRData(cB_small, metadf)  # Find reliable features features_to_keep <- reliableFeatures(obj = bakRData) # }"},{"path":"https://simonlabcode.github.io/bakR/reference/validate_bakRData.html","id":null,"dir":"Reference","previous_headings":"","what":"bakR Data object validator — validate_bakRData","title":"bakR Data object validator — validate_bakRData","text":"functions ensures input bakRData object construction valid","code":""},{"path":"https://simonlabcode.github.io/bakR/reference/validate_bakRData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bakR Data object validator — validate_bakRData","text":"","code":"validate_bakRData(obj)"},{"path":"https://simonlabcode.github.io/bakR/reference/validate_bakRData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bakR Data object validator — validate_bakRData","text":"obj object class bakRData","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-024","dir":"Changelog","previous_headings":"","what":"bakR 0.2.4","title":"bakR 0.2.4","text":"CRAN release: 2022-10-10 Addressed NOTEs prepare CRAN submission Removed previously deprecated function sim_bakRData()","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-023","dir":"Changelog","previous_headings":"","what":"bakR 0.2.3","title":"bakR 0.2.3","text":"Expanded discussion NSS analysis vignette","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-022","dir":"Changelog","previous_headings":"","what":"bakR 0.2.2","title":"bakR 0.2.2","text":"Fixed non-steady-state (NSS) uncertainty quantification Fixed uncertainty quantification pulse-chase analysis Fixed fraction new estimation pulse-chase analysis","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-021","dir":"Changelog","previous_headings":"","what":"bakR 0.2.1","title":"bakR 0.2.1","text":"Added pulse-chase analysis option","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-020","dir":"Changelog","previous_headings":"","what":"bakR 0.2.0","title":"bakR 0.2.0","text":"Improved default mutation rate estimation strategy Updated vignettes added back non-steady state analysis strategy discussion Better commenting fast_analysis (instead opting refactorization)","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-011","dir":"Changelog","previous_headings":"","what":"bakR 0.1.1","title":"bakR 0.1.1","text":"Changed ordering vignettes website Got rid unnecessary stan models functions Fixed TL_stan output documentation Corrected missing namespace issues","code":""},{"path":"https://simonlabcode.github.io/bakR/news/index.html","id":"bakr-010","dir":"Changelog","previous_headings":"","what":"bakR 0.1.0","title":"bakR 0.1.0","text":"Made bakR public","code":""}]
