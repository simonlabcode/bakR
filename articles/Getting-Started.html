<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="bakR">
<title>Differential kinetic analysis with bakR • bakR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Differential kinetic analysis with bakR">
<meta property="og:description" content="bakR">
<meta property="og:image" content="https://simonlabcode.github.io/bakR/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">bakR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.4</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/Getting-Started.html">Differential kinetic analysis with bakR</a>
    <a class="dropdown-item" href="../articles/Further-Analyses.html">Going beyond the defaults with bakR</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/simonlabcode/bakR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Differential kinetic analysis with bakR</h1>
                        <h4 data-toc-skip class="author">Isaac Vock</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/simonlabcode/bakR/blob/HEAD/vignettes/Getting-Started.Rmd" class="external-link"><code>vignettes/Getting-Started.Rmd</code></a></small>
      <div class="d-none name"><code>Getting-Started.Rmd</code></div>
    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>In a standard RNA-seq experiment, differential expression
      analysis is incredibly common. The idea is to compare the
      expression of thousands of transcripts between two conditions,
      which I’ll refer to as the reference and experimental samples.
      Once you have compiled a list of genes whose expressions differ
      significantly between the two conditions, a reasonable follow-up
      question is “what caused the change in each of the genes”? The
      three broad answers to that question are 1) Something altered the
      RNA synthesis rates; 2) Something altered the RNA degradation
      rates; or 3) A little bit of both 1) and 2). Unfortunately,
      standard RNA-seq analysis cannot answer this mechanistic question,
      as RNA-seq only tells you about changes in expression level and
      cannot deduce the kinetic causes of those changes.</p>
      <p>If the kinetics is of interest to you, then a recently
      developed solution to this problem is nucleotide recoding RNA-seq,
      which exists in several fundamentally similar flavors, the primary
      ones being TimeLapse-seq, SLAM-seq, and TUC-seq. The strategy
      involves feeding cells with a metabolic label (typically
      4-thiouridine, a.k.a. 4sU), extracting the RNA as you normally
      would for RNA-seq, and then using a unique chemistry to convert
      the metabolic label into something that a sequencer will read as a
      different base (e.g., a cytosine analog for 4sU). Thus, labeled
      and unlabeled reads can be separated bioinformatically upon
      sequencing by the presence of mutations (e.g., U-to-C
      mutations).</p>
      <p>One problem though; the metabolic label must 1st get into
      cells, and then it must compete with the normal nucleotide for
      incorporation into RNA. The result of this is that mutation rates
      are typically low (often around 5% in RNA produced during
      metabolic labeling, meaning that each U in a sequencing read from
      these RNAs has about a 5% chance of being mutated to a C), making
      simple and definitive separation of labeled and unlabeled reads
      impossible. The solution: advanced statistical modeling
      implemented by bakR, an R package for analyzing nucleotide
      recoding sequencing data. The analyses implemented in this package
      will enable you to perform differential kinetic analysis just as
      easily as you can perform differential expression analysis,
      allowing you to elucidate the mechanisms of regulated gene
      expression.</p>
    </div>
    
<div class="section level2">
<h2 id="necessary-setup">Necessary Setup<a class="anchor" aria-label="anchor" href="#necessary-setup"></a>
</h2>
<p>Of course you will want to load the bakR package for this vignette;
instructions to do so can be found at this <a href="https://simonlabcode.github.io/bakR/index.html">link</a>. Also,
you’ll want to set the seed so as to ensure the results you get
reproduce those presented in the vignette.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://simonlabcode.github.io/bakR/">bakR</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="step-1-creating-a-bakrdata-object">Step 1: Creating a bakRData Object<a class="anchor" aria-label="anchor" href="#step-1-creating-a-bakrdata-object"></a>
</h2>
<p>The 1st step to using bakR is to create a bakRData object. A bakRData
object consists of two components: a cB dataframe and a metadf
dataframe. cB stands for counts binomial and contains all of the
information about mutations seen in sequencing reads in each sample
sequenced. metadf stands for metadata data frame and contains important
information about the experimental details of each sample (i.e., how
long the metabolic label feed was, which samples are reference samples,
and which are experimental samples).</p>
<p>Lets get an idea for what a cB looks like by taking a peak at an
example:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load small example cB</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"cB_small"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Observe contents of cB</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">cB_small</span><span class="op">)</span></span></code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="left">sample</th>
<th align="right">nT</th>
<th align="left">XF</th>
<th align="right">TC</th>
<th align="right">n</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">WT_ctl</td>
<td align="right">9</td>
<td align="left">ENSG00000156928</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">WT_ctl</td>
<td align="right">11</td>
<td align="left">ENSG00000105849</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="left">WT_ctl</td>
<td align="right">12</td>
<td align="left">ENSG00000100242</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">WT_ctl</td>
<td align="right">12</td>
<td align="left">ENSG00000105849</td>
<td align="right">0</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="left">WT_ctl</td>
<td align="right">12</td>
<td align="left">ENSG00000196295</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">WT_ctl</td>
<td align="right">12</td>
<td align="left">ENSG00000198937</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>One key aspect of the cB dataframe to keep in mind is that each row
corresponds to a set of reads providing identical data. To help that
make more sense, and to understand what information the cB tracks, let’s
go through the contents of each column:</p>
<ol style="list-style-type: decimal">
<li>
<strong>sample</strong>: This is the name of the sample from which
the reads described in this row originated. Usually this will be some
sort of character vector that you have defined.</li>
<li>
<strong>TC</strong>: Number of U-to-C mutations (assuming using 4sU
as the metabolic label). Called TC because technically the data is
T-to-C mutations in reverse-transcribed RNA</li>
<li>
<strong>nT</strong>: Number of Ts (Us in the RNA) in the sequencing
read(s)</li>
<li>
<strong>XF</strong>: Name of the feature (gene, exon, etc.) that the
read comes from. Kinetic parameters will be estimated for each feature,
so this should represent the functional unit who’s metabolic kinetics
you are interested in.
<ul>
<li>
<strong>XF</strong> stands for “exonic feature”, since in most cases
you should only be considering reads that map to definitively exonic
locations. Introns are typically rapidly turned over and thus will be
highly labeled species that will bias estimates of mature transcript
stability.</li>
</ul>
</li>
<li>
<strong>n</strong>: Number of reads with identical data for the
other 4 columns. For example, n = 3 in the 2nd row means that there are
3 reads from sample WT_cntl (WT cells not treated with s4U) that mapped
to <strong>XF</strong> ENSG00000100242 (SUN2), had 0 T to C mutations,
and had 11 Ts.</li>
</ol>
<p>The structure of the cB file most closely reflects the output of a
pipeline for analyzing nucleotide recoding RNA-seq data developed by the
Simon lab (available <a href="https://bitbucket.org/mattsimon9/timelapse_pipeline/src/master/" class="external-link">here</a>),
but consists of data provided by another published pipeline, SLAMDUNK
(see the alleyoop dump function in SLAMDUNK).</p>
<p>Now let’s look at the corresponding metadf dataframe:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load metadf data frame; will be loaded as metadf in global environment</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"metadf"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Print the transpose of metadf</span></span>
<span><span class="co"># Rows will be the columns and columns will be the rows</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">metadf</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="left"></th>
<th align="right">WT_ctl</th>
<th align="right">WT_2</th>
<th align="right">WT_1</th>
<th align="right">KO_ctl</th>
<th align="right">KO_2</th>
<th align="right">KO_1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">tl</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="left">Exp_ID</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>The transpose of metadf is displayed above to save space (so the
columns depicted are the rows of metadf, and vice versa). Metadf has
significantly less information than the cB data frame, but it’s crucial
information. One extremely important feature of metadf is its row names
(column names as depicted above). Examine the row names and compare them
to the sample names</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># metadf row names</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">metadf</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "WT_ctl" "WT_2"   "WT_1"   "KO_ctl" "KO_2"   "KO_1"</span></span>
<span></span>
<span></span>
<span><span class="co"># cB sample names</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">cB_small</span><span class="op">$</span><span class="va">sample</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "WT_ctl" "WT_2"   "WT_1"   "KO_ctl" "KO_2"   "KO_1"</span></span></code></pre></div>
<p>They’re the same, and they HAVE TO BE!! Each row of metadf
corresponds to a sample, and the order in which the sample names appear
as the row names of metadf <strong>MUST</strong> correspond to the order
they appear in cB sample column.</p>
<p>Keeping in mind that each row represents a sample, the content of the
columns are:</p>
<ol style="list-style-type: decimal">
<li>
<strong>tl</strong>: The length of the metabolic labeling feed. This
can be in any units (the simulated data puts it in terms of minutes),
but <strong>if no 4sU was fed to a sample, tl must be 0 for that
sample</strong>. -4sU controls play an important role in all of the
statistical models, so this is crucial to remember. While not
technically necessary to run bakR, we always highly suggest including
these controls.</li>
<li>
<strong>Exp_ID</strong>: Stands for “Experimental ID” and is a
numerical ID that denotes which samples are from the reference condition
and which experimental samples belong to the same “treatment”. In this
simulated dataset, there are two conditions, a reference condition
(samples 1, 2, 3, and 7) and a single experimental condition (samples 4,
5, 6, and 8). <strong>The reference condition must be given numerical ID
1</strong> and <strong>the experimental conditions must be given
sequential numerical IDs starting from 2</strong> (i.e., 2, 3, 4, …).
You can have more than one experimental sample, but all comparisons will
only be done with respect to one reference sample.
<ul>
<li>If you want to compare two experimental samples, this can be done
with the output of the models, though it will require a bit of post-hoc
work on your end. More on this later…</li>
</ul>
</li>
</ol>
<p>Once you have these two data frames correctly constructed, you can
create a bakRData object in one line of code.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Create bakRData object</span></span>
<span><span class="va">bakRData</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bakRData.html">bakRData</a></span><span class="op">(</span><span class="va">cB_small</span>, <span class="va">metadf</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="step-2-fitting-the-efficient-model">Step 2: Fitting the Efficient Model<a class="anchor" aria-label="anchor" href="#step-2-fitting-the-efficient-model"></a>
</h2>
<p>bakR implements several blends of fundamentally similar statistical
models to perform differential kinetic analysis. No matter your
intentions though, you must first fit data with the most efficient model
available. This model (implemented in the fast_analysis() function, so
see ?fast_analysis for more details) estimates mutation rates and then
finds the maximum likelihood estimate (MLE) for the fraction of
sequencing reads from new RNA (new meaning RNA synthesized after the
start of metabolic labeling) for each feature in each 4sU fed sample.
The reason you have to run this model is that some part of its output
will be used by every other model you can run with bakR. More on that
later though; first, let’s create a simulated dataset and fit it with
the efficient model. Using a simulated dataset will allow us to compare
the results to the ground truth and validate its accuracy.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Simulate a nucleotide recoding dataset</span></span>
<span><span class="va">sim_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Simulate_bakRData.html">Simulate_bakRData</a></span><span class="op">(</span><span class="fl">500</span><span class="op">)</span></span>
<span>  <span class="co"># This will simulate 500 features, 2 experimental conditions</span></span>
<span>  <span class="co"># and 3 replicates for each experimental condition</span></span>
<span>  <span class="co"># See ?Simulate_bakRData for details regarding tunable parameters</span></span>
<span></span>
<span><span class="co"># Extract simulated bakRData object</span></span>
<span><span class="va">bakRData</span> <span class="op">&lt;-</span> <span class="va">sim_data</span><span class="op">$</span><span class="va">bakRData</span></span>
<span></span>
<span><span class="co"># Extract simualted ground truths</span></span>
<span><span class="va">sim_truth</span> <span class="op">&lt;-</span> <span class="va">sim_data</span><span class="op">$</span><span class="va">sim_list</span></span>
<span></span>
<span><span class="co"># Run the efficient model</span></span>
<span><span class="va">Fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bakRFit.html">bakRFit</a></span><span class="op">(</span><span class="va">bakRData</span><span class="op">)</span></span>
<span><span class="co">#&gt; Finding reliable Features</span></span>
<span><span class="co">#&gt; Filtering out unwanted or unreliable features</span></span>
<span><span class="co">#&gt; Processing data...</span></span>
<span><span class="co">#&gt; Estimating labeled mutation rate</span></span>
<span><span class="co">#&gt; Estimated pnews for each sample are:</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 6 × 3</span></span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># Groups:   mut [2]</span></span></span>
<span><span class="co">#&gt;     mut  reps   pnew</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span>     1     1 0.050<span style="text-decoration: underline;">1</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span>     1     2 0.049<span style="text-decoration: underline;">9</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">3</span>     1     3 0.050<span style="text-decoration: underline;">0</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">4</span>     2     1 0.050<span style="text-decoration: underline;">1</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">5</span>     2     2 0.050<span style="text-decoration: underline;">2</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">6</span>     2     3 0.050<span style="text-decoration: underline;">0</span></span></span>
<span><span class="co">#&gt; Estimating unlabeled mutation rate</span></span>
<span><span class="co">#&gt; Estimated pold is:  0.001</span></span>
<span><span class="co">#&gt; Estimating fraction labeled</span></span>
<span><span class="co">#&gt; Estimating per replicate uncertainties</span></span>
<span><span class="co">#&gt; Estimating read count-variance relationship</span></span>
<span><span class="co">#&gt; Averaging replicate data and regularizing estimates</span></span>
<span><span class="co">#&gt; Assessing statistical significance</span></span>
<span><span class="co">#&gt; All done! Run QC_checks() on your bakRFit object to assess the quality of your data and get recommendations for next steps.</span></span></code></pre></div>
<p>bakRFit() is used here as a wrapper for two functions in bakR:
cBprocess() and fast_analysis(). cBprocess() will extract and properly
format the information needed for all statistical models from the
bakRData object and fast_analysis() will perform the efficient analysis.
This should take no more than a minute to run. Messages are printed
along the way to keep you updated as to the progress of the
analysis.</p>
<p>One of the most important messages is that regarding the estimated
pnews and pold. The pnews are the estimated mutation rates of reads from
new RNAs (new meaning RNAs synthesized after the start of 4sU labeling)
in each sample (muts = Exp_ID, and reps = a numerical replicate ID that
corresponds to the order replicates appear in the cB), and pold is a
global estimate of the background mutation rate used in all analyses.
The simulated mutation rates are 0.05 for new reads and 0.001 for old
reads in all samples this simulation, so the estimates are pretty darn
close. You can also input mutation rate estimates from elsewhere (say a
run of the full Stan model implemented in bakR) to bakRFit():</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Run efficient model with known mutation rates</span></span>
<span><span class="co"># Pass the Fit object rather than the bakRData object and set FastRerun to TRUE</span></span>
<span><span class="va">Fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bakRFit.html">bakRFit</a></span><span class="op">(</span><span class="va">Fit</span>,</span>
<span>                     FastRerun <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                     pnew <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.05</span>, times <span class="op">=</span> <span class="fl">6</span><span class="op">)</span>, </span>
<span>                     pold <span class="op">=</span> <span class="fl">0.001</span><span class="op">)</span></span>
<span><span class="co">#&gt; Estimating fraction labeled</span></span>
<span><span class="co">#&gt; Estimating per replicate uncertainties</span></span>
<span><span class="co">#&gt; Estimating read count-variance relationship</span></span>
<span><span class="co">#&gt; Averaging replicate data and regularizing estimates</span></span>
<span><span class="co">#&gt; Assessing statistical significance</span></span>
<span><span class="co">#&gt; All done! Run QC_checks() on your bakRFit object to assess the quality of your data and get recommendations for next steps.</span></span></code></pre></div>
<p>Since we’ve already run the fast_analysis once, we can speed up the
analysis by passing the Fit object from the first run rather than the
bakRData object. This allows bakR to skip the time consuming
pre-processing steps. Just make sure to set FastRerun to TRUE.</p>
<p>If you run into problems with the default mutation rate strategy
(e.g., the mutation rate estimates don’t seem to make sense) another
slightly less efficient solution is to use MCMC implemented in Stan to
estimate mutation rates. The idea is to fit a binomial mixture model to
only a small subset of features with sufficient sequencing depth so that
the model has enough data to work with. This strategy used to be my
go-to strategy, but after I made improvements to the default mutation
rate strategy I found myself using this approach less and less. Still,
here is an example of its use for posterity’s sake:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Set StanRateEst to TRUE to use Stan to estimate rates</span></span>
<span><span class="co"># low_reads and high_reads defines the read count cutoffs used to select features</span></span>
<span>  <span class="co"># default = between 1000 and 5000 reads</span></span>
<span><span class="co"># RateEst_size determines the number of features to use (default = 7)</span></span>
<span><span class="va">Fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bakRFit.html">bakRFit</a></span><span class="op">(</span><span class="va">Fit</span>,</span>
<span>                     FastRerun <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                     StanRateEst <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                     low_reads <span class="op">=</span> <span class="fl">500</span>,</span>
<span>                     high_reads <span class="op">=</span> <span class="fl">5500</span>,</span>
<span>                     RateEst_size <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<p>No matter how you decide to run the fast model, you might wonder how
well it worked. As mentioned earlier, one benefit of using simulated
data is that you can easily answer that question by comparing the
simulated parameters (e.g., the fraction new) to the model’s
estimates:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="co"># Features that made it past filtering</span></span>
<span><span class="va">XFs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">Fit</span><span class="op">$</span><span class="va">Fast_Fit</span><span class="op">$</span><span class="va">Effects_df</span><span class="op">$</span><span class="va">XF</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Simulated logit(fraction news) from features making it past filtering</span></span>
<span><span class="va">true_fn</span> <span class="op">&lt;-</span> <span class="va">sim_truth</span><span class="op">$</span><span class="va">Fn_rep_sim</span><span class="op">$</span><span class="va">Logit_fn</span><span class="op">[</span><span class="va">sim_truth</span><span class="op">$</span><span class="va">Fn_rep_sim</span><span class="op">$</span><span class="va">Feature_ID</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="va">XFs</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Estimated logit(fraction news)</span></span>
<span><span class="va">est_fn</span> <span class="op">&lt;-</span> <span class="va">Fit</span><span class="op">$</span><span class="va">Fast_Fit</span><span class="op">$</span><span class="va">Fn_Estimates</span><span class="op">$</span><span class="va">logit_fn</span></span>
<span></span>
<span><span class="co"># Compare estimate to truth</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">true_fn</span>, <span class="va">est_fn</span>, xlab <span class="op">=</span> <span class="st">"True logit(fn)"</span>, ylab <span class="op">=</span> <span class="st">"Estimated logit(fn)"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Getting-Started_files/figure-html/unnamed-chunk-11-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Looks pretty good to me!</p>
<p>To run the heavier, more trustworthy models, just rerun bakRFit() on
the Fit object, but with either the StanFit or HybridFit parameters set
to true.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load options that will make running models more efficient</span></span>
<span><span class="fu">rstan</span><span class="fu">::</span><span class="fu"><a href="https://mc-stan.org/rstan/reference/rstan_options.html" class="external-link">rstan_options</a></span><span class="op">(</span>auto_write <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>mc.cores <span class="op">=</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">detectCores</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co"># Run Hybrid model (This might take several minutes to run)</span></span>
<span><span class="va">Fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bakRFit.html">bakRFit</a></span><span class="op">(</span><span class="va">Fit</span>, HybridFit <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Run Full model (This might take ~10-30 minutes to run)</span></span>
<span><span class="va">Fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bakRFit.html">bakRFit</a></span><span class="op">(</span><span class="va">Fit</span>, StanFit <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>You might rightfully ask what it is that makes these models “more
trustworthy”? Didn’t we just show that the logit(fn) estimates for the
fast model were pretty good? Why bother with these computationally
expensive models?? The answer is that a lot of the magic happens at the
level of uncertainty quantification. While all models are going to agree
pretty well on estimates for kinetic parameters, they won’t necessarily
agree on how uncertain those estimates are. The fastest model takes a
lot of shortcuts and uses a lot of approximations that make it fast but
also make its uncertainty quantification less rigorous. I like to say
that the fast model should be used for initial investigations of your
data, a rapid means by which to satisfy your desire to dive into
whatever exciting biology you might be exploring. When you have a sense
of how promising your data is and what it is you want to analyze, switch
on over to the heavier models. These will give you more peace of mind
and allow you to comfortably dig a little deeper into your datasets as
you prepare for stunning presentations and groundbreaking papers. The
full Stan model (StanFit = TRUE) should be your go-to for this, but if
you are working with an unusually large dataset, look to the hybrid
model. A general rule of thumb for what constitutes a large dataset in
this case is if (number of experimental conditions) x (number of
replicates of each condition) is greater than 15. For example, 3
replicates of 6 different conditions (3 x 6 = 18) is going to take a
while for the full model to process, likely on the order of weeks.</p>
<p>The Fit objects contain lists pertaining to the fits of each of the
models. The possible contents include:</p>
<ol style="list-style-type: decimal">
<li>Fast_Fit: Result of the initial fitting of the bakRData object. To
learn more about its contents, see ?fast_analysis()</li>
<li>Data_lists: Processed data that can be passed to the statistical
models</li>
<li>Hybrid_Fit: Result of running bakRFit() on the Fit object with
HybridFit = TRUE. To learn more about its contents, see ?TL_stan().</li>
<li>Stan_Fit: Result of running bakRFit() on the Fit object with StanFit
= TRUE. Its general contents are identical to the Hybrid_Fit, even
though the models are different.</li>
</ol>
</div>
<div class="section level2">
<h2 id="step-3-visualizing-the-results">Step 3: Visualizing the Results<a class="anchor" aria-label="anchor" href="#step-3-visualizing-the-results"></a>
</h2>
<p>bakR provides a variety of easy to use functions for beginning to
investigate your data. The visualizations are particularly aimed at
revealing trends in RNA stabilization or destabilization. Analyzing
changes in RNA synthesis rate will require pairing the output of bakR
with that of a differential expression analysis tool, like DESeq2 or
limma. More on that later.</p>
<p>One visualization powered by bakR is a L2FC(kdeg) MA plot. Each point
in these plots will represent a feature-condition combination. The
x-axis is the average number of sequencing reads mapping to that
feature, averaging over all replicates in both the experimental and
reference condition. The y-axis is the difference in stability between
the reference and experimental condition, quantified as a log2-fold
change (L2FC) in the degradation rate constant (kdeg). Positive values
of L2FC(kdeg) represent features that are less stable (have a higher
kdeg) in the experimental condition relative to the reference condition.
Negative values thus represent features that are more stable in the
experimental condition. The plotMA function in bakR allows you to make
this plot with two inputs, the bakRFit object and the model fit to use
(MLE, Hybrid, or MCMC):</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## MA Plot with Fast Fit</span></span>
<span><span class="fu">bakR</span><span class="fu">::</span><span class="fu"><a href="../reference/plotMA.html">plotMA</a></span><span class="op">(</span><span class="va">Fit</span>, Model <span class="op">=</span> <span class="st">"MLE"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Getting-Started_files/figure-html/unnamed-chunk-13-1.png" width="576" style="display: block; margin: auto;"></p>
<p>If you have more than one experimental condition, you can choose to
plot all comparisons or just a subset of those in which you are
interested. See the Exps and Exp_shape parameters in the ?plotMA help
file for details.</p>
<p>Another common plot to make with the bakR fits is a volcano plot. The
x-axis in a volcano plot is the same as the y-axis of an MA plot (so
L2FC in a kinetic parameter), and the y-axis is a measure of statistical
significance (e.g., FDR adjusted p-value), usually on a -log10 scale.
The plotVolcano function is here to help you with this one too,
containing many of the same parameters as plotMA:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Volcano Plot with Fast Fit; significance assessed relative to an FDR control of 0.05</span></span>
<span><span class="fu"><a href="../reference/plotVolcano.html">plotVolcano</a></span><span class="op">(</span><span class="va">Fit</span><span class="op">$</span><span class="va">Fast_Fit</span><span class="op">)</span></span></code></pre></div>
<p><img src="Getting-Started_files/figure-html/unnamed-chunk-14-1.png" width="576" style="display: block; margin: auto;"></p>
<p>While volcano and MA plots are great for visualizing the results of
bakR’s model fits, another important class of plots are those to detect
anomalies. Sometimes, high-throughput sequencing datasets are plagued by
batch effects, biases that effect one or a few of your samples. These
can lead to inflated false discovery rates and/or reduced power and are
thus important to look out for. One simple way to see if there are
large-scale biases present in any of your samples is to perform
principle component analysis (PCA), a dimension reduction algorithm that
will project your high-dimensional sequencing data onto a few
dimensions. bakR specifically implements a novel fraction new PCA, where
the high-dimensional object to be compressed is a matrix of fraction new
estimates, with each column of the matrix corresponding to a sample and
each row a feature (e.g., a transcript). If replicates don’t cluster
together in the 2D PCA plot produced by bakR’s FnPCA, that could
indicate the presence of batch effects:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## 2D PCA plot with replicate fraction news</span></span>
<span><span class="fu"><a href="../reference/FnPCA.html">FnPCA</a></span><span class="op">(</span><span class="va">Fit</span><span class="op">$</span><span class="va">Fast_Fit</span><span class="op">)</span></span></code></pre></div>
<p><img src="Getting-Started_files/figure-html/unnamed-chunk-15-1.png" width="576" style="display: block; margin: auto;"></p>
<p>In this case, replicates separate from each other fairly well, which
is promising and the difference between the red point in the lower left
and those in the upper left is not significant enough to cause concern.
I have found that clustering is improved with the full MCMC fit, so if
you’ve taken the time to run that model, I suggest using it for any PCA
plots.</p>
</div>
<div class="section level2">
<h2 id="step-4-where-to-go-from-here">Step 4: Where to go from here<a class="anchor" aria-label="anchor" href="#step-4-where-to-go-from-here"></a>
</h2>
<p>I hope that this vignette has provided a useful introduction to using
bakR with your nucleotide recoding RNA-seq datasets. Inevitably, not all
of your questions will be answered in the Getting-Started vignette. Some
of your remaining quandaries may be challenging problems specific to
your exciting research, the unavoidable roadblocks of doing science that
you will eventually conquer, but with little help from any documentation
I could dream of writing. That being said, I can still imagine many
important implementation questions not addressed here, like:</p>
<ol style="list-style-type: decimal">
<li>What about estimating and comparing synthesis rates? bakR seems to
only automatically perform degradation rate constant comparisons, but
you keep calling it differential kinetic analysis, not differential
stability analysis. What gives?</li>
<li>I’m not sure this steady-state assumption we’ve been relying on
holds in my system. What can I do about that?</li>
<li>I’m new to Stan and have been getting weird warning messages upon
running some of the heavier models. What are rhats and effective sample
sizes?</li>
</ol>
<p>If the first two questions are of interest to you, head over to the
“Going beyond the defaults” vignette!</p>
<p>If the second question is of interest, then I would suggest heading
over to some of the amazing documentation written by the Stan team. In
short though, warnings from Stan are a sign that the model did not
converge. The cause of this is likely anomalies in your data. Some
challenges that I have come across that could lead to such warnings
include:</p>
<ol style="list-style-type: decimal">
<li>Did you analyze a mix of technical and biological replicates?
Technical replicates will have much less replicate to replicate
variability than biological replicates, which will confuse and crash the
models.</li>
<li>Is your 4sU label time abnormally long or short? If you are getting
warnings from running the MLE implementation about logit(fn)s being at
the lower or upper bounds, this could be the case. It means that there
will be some extreme mutational data (e.g., 0 mutations in any
sequencing read) that will make analysis with the MCMC implementation
more difficult. Try filtering out these extreme transcripts and
rerunning bakR if this is the case.</li>
<li>Do you have any extreme batch effects. Check the FnPCA plot; extreme
differences between replicates could also break the models.</li>
<li>Are you analyzing short sequencing reads? bakR has not yet been
fully validated on short sequencing read nucleotide recoding RNA-seq
data (e.g., read lengths less than 50 nucleotides), so exercise caution
when analyzing this kind of data with bakR. Mutation rate estimation can
also pose a challenge for bakR in this case. To get around these
problems, try using the mutation rate estimates from the MCMC
implementation (which I have found to be accurate even when model
convergence is an issue) in the MLE implementation.</li>
</ol>
<p>Sometimes, small warnings from Stan (like a few max treedepth
warnings here and there) are no cause for concern. How do you know
whether or not there is a serious problem though? I would suggest
comparing the output of the Hybrid/MCMC implementation to that of the
MLE implementation. In particular, check the correlation between the
L2FC(kdeg) estimates. If the correlation is good, then there probably is
nothing to worry about. If the estimates for a handful of transcripts
differ wildly between the implementations though, that is strong
evidence that the model didn’t converge and that one of the anomalies
mentioned above is afflicting your data.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Isaac Vock.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
